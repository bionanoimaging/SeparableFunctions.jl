<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Radial Functions · SeparableFunctions.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SeparableFunctions.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">SeparableFunctions.jl</a></li><li><a class="tocitem" href="../separables/">Concrete Separable Functions</a></li><li class="is-active"><a class="tocitem" href>Radial Functions</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Radial Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Radial Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/master/docs/src/radial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Radial-functions"><a class="docs-heading-anchor" href="#Radial-functions">Radial functions</a><a id="Radial-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Radial-functions" title="Permalink"></a></h1><p>These functions are purely radial, in which case only a quadrant is computed and then copied. They are all based on a separable view version of <code>rr2</code> but then continue to calculate on a corner of a grid, which is (as a last step) replicated and mirrored.</p><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.calc_radial_symm" href="#SeparableFunctions.calc_radial_symm"><code>SeparableFunctions.calc_radial_symm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">calc_radial_symm!([::Type{TA},] sz::NTuple,  fct; scale = one(real(T)), myrr2sep = rr2_sep(size(arr); scale=scale, offset=size(arr).÷2 .+1)) where {N,T}</code></pre><p>evaluates the radial function <code>fct</code> over the entire array. The function needs to accept the radius as argument. The calculation is done fast by only evaluating on the first quadrant and replicating the results by copy operations using <code>copy_corners!()</code>.</p><p>#Arguments</p><ul><li><code>TA</code>:         The array type for the newly created array. </li><li><code>sz</code>:         The size of the newly created array. </li><li><code>fct</code>:        The function of the radius, to be evaluate on the array coordinates. </li><li><code>scale</code>:      the vetorized scaling of the pixels (only used, if myrr2sep is not supplied by the user)</li><li><code>myrr2sep</code>:   The separable xx^2 and yy^2 etc. information as obtained by <code>rr2_sep()</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/f6385f1de91d73668271ecbd29154ca52678c2b6/src/radial.jl#L167-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.calc_radial_symm!" href="#SeparableFunctions.calc_radial_symm!"><code>SeparableFunctions.calc_radial_symm!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">calc_radial_symm!(arr::TA, fct; scale = one(real(T)), myrr2sep = rr2_sep(size(arr); scale=scale, offset=size(arr).÷2 .+1)) where {N,T}</code></pre><p>evaluates the radial function <code>fct</code> over the entire array. The function needs to accept the radius as argument. The calculation is done fast by only evaluating on the first quadrant and replicating the results by copy operations using <code>copy_corners!()</code>.</p><p>#Arguments</p><ul><li><code>arr</code>:    The array into which to evaluate the radial function </li><li><code>fct</code>:        The function of the radius, to be evaluate on the array coordinates. </li><li><code>scale</code>:      the vetorized scaling of the pixels (only used, if myrr2sep is not supplied by the user)</li><li><code>myrr2sep</code>:   The separable xx^2 and yy^2 etc. information as obtained by <code>rr2_sep()</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/f6385f1de91d73668271ecbd29154ca52678c2b6/src/radial.jl#L151-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.propagator_col" href="#SeparableFunctions.propagator_col"><code>SeparableFunctions.propagator_col</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">propagator_col([]::Type{TA},] sz::NTuple{N, Int}; Δz=one(eltype(TA)), k_max=0.5f0, scale=0.5f0 ./ (max.(sz ./ 2, 1))) where{TA, N}</code></pre><p>generates a propagator for propagating optical fields via exp(i kz Δz) with kz=sqrt(k0^2-kx^2-ky^2). The k-space radius is stated by k_max relative to the Nyquist frequency, as long as the scale remains to be 1 ./ (2 max.(sz ./ 2, 1))).</p><p>#Arguments</p><ul><li><code>TA</code>:     type of the array to generate. E.g. Array{Float64} or CuArray{Float32}.</li><li><code>sz</code>:     size of the array to generate.  If a 3rd dimension is present, a stack a propagators is returned, one for each multiple of Δz.</li><li><code>Δz</code>:     distance in Z to propagate per slice.</li><li><code>k_max</code>:  maximum propagation radius in k-space. I.e. limit of the k-sphere. This is not the aperture limit!</li><li><code>scale</code>:  specifies how to interpret k-space positions. Should remain to be 1 ./ (2 max.(sz ./ 2, 1))).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/f6385f1de91d73668271ecbd29154ca52678c2b6/src/specific.jl#L91-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.propagator_col!" href="#SeparableFunctions.propagator_col!"><code>SeparableFunctions.propagator_col!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">propagator_col(arr::AbstractArray{T,N}; Δz=one(eltype(TA)), k_max=0.5f0, scale=0.5f0 ./ (max.(sz ./ 2, 1))) where{TA, N}</code></pre><p>generates a propagator for propagating optical fields via exp(i kz Δz) with kz=sqrt(k0^2-kx^2-ky^2). The k-space radius is stated by k_max relative to the Nyquist frequency, as long as the scale remains to be 1 ./ (2 max.(sz ./ 2, 1))).</p><p>#Arguments</p><ul><li><code>arr</code>:    the array to fill with propagators. If a 3rd dimension is present, a stack a propagators is returned, one for each multiple of Δz.</li><li><code>Δz</code>:     distance in Z to propagate per slice.</li><li><code>k_max</code>:  maximum propagation radius in k-space. I.e. limit of the k-sphere. This is not the aperture limit!</li><li><code>scale</code>:  specifies how to interpret k-space positions. Should remain to be 1 ./ (2 max.(sz ./ 2, 1))).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/f6385f1de91d73668271ecbd29154ca52678c2b6/src/specific.jl#L117-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.phase_kz_col" href="#SeparableFunctions.phase_kz_col"><code>SeparableFunctions.phase_kz_col</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">phase_kz_col([::Type{TA},] sz::NTuple{N, Int};k_max=0.5f0, scale=0.5f0 ./ (max.(sz ./ 2, 1))) where{TA, N}</code></pre><p>Calculates a propagation phase (without the 2pi factor!) for a given z-position, which can be defined via a 3rd entry in the <code>offset</code> supplied to the function. By default, Nyquist sampling it is assumed such that the lateral k<em>xy corresponds to the XY border in frequency space at the edge  of the Ewald circle. However, via the xy <code>scale</code> entries the k</em>max can be set appropriately. The propagation equation should Δz .* sqrt.(1-kxy<em>rel^2) as the propagation phase. The Z-propagation distance (Δz) has to be specified in  units of the wavelength in the medium (<code>λ = n*λ₀</code>). Note that since the phase is normalized to 1 instead of 2pi, you need to use this phase in the following sense: `cispi.(2.*phase</em>kz(...))`.</p><p>#Arguments</p><ul><li><code>TA</code>:     Array type of the result array. For cuda calculations use <code>CuArray{Float32}</code>.</li><li><code>sz</code>:     Size (2D) of the result array. </li><li><code>k_max</code>:  maximum propagation radius in k-space. I.e. limit of the k-sphere. This is not the aperture limit!</li><li><code>scale</code>:  specifies how to interpret k-space positions. Should remain to be 1 ./ (2 max.(sz ./ 2, 1))).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/f6385f1de91d73668271ecbd29154ca52678c2b6/src/specific.jl#L150-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.phase_kz_col!" href="#SeparableFunctions.phase_kz_col!"><code>SeparableFunctions.phase_kz_col!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">phase_kz_col!(arr::AbstractArray{T,N}; k_max=0.5f0, scale=0.5f0 ./ (max.(sz ./ 2, 1))) where{TA, N}</code></pre><p>Calculates a propagation phase (without the 2pi factor!) for a given z-position, which can be defined via a 3rd entry in the <code>offset</code> supplied to the function. By default, Nyquist sampling it is assumed such that the lateral k<em>xy corresponds to the XY border in frequency space at the edge  of the Ewald circle. However, via the xy <code>scale</code> entries the k</em>max can be set appropriately. The propagation equation uses Δz .* sqrt.(1-kxy<em>rel^2) as the propagation phase. The Z-propagation distance (Δz) has to be specified in  units of the wavelength in the medium (<code>λ = n*λ₀</code>). Note that since the phase is normalized to 1 instead of 2pi, you need to use this phase in the following sense: `cispi.(2.*phase</em>kz(...))`.</p><p>#Arguments</p><ul><li><code>arr</code>:    the array to fill with propagators. If a 3rd dimension is present, a stack a propagators is returned, one for each multiple of Δz.</li><li><code>k_max</code>:  maximum propagation radius in k-space. I.e. limit of the k-sphere. This is not the aperture limit!</li><li><code>scale</code>:  specifies how to interpret k-space positions. Should remain to be 1 ./ (2 max.(sz ./ 2, 1))).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/f6385f1de91d73668271ecbd29154ca52678c2b6/src/specific.jl#L175-L190">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../separables/">« Concrete Separable Functions</a><a class="docs-footer-nextpage" href="../utilities/">Utilities »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 5 September 2022 13:05">Monday 5 September 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
