var documenterSearchIndex = {"docs":
[{"location":"separables/#Concrete-SeparableFunctions","page":"Concrete Separable Functions","title":"Concrete SeparableFunctions","text":"","category":"section"},{"location":"separables/","page":"Concrete Separable Functions","title":"Concrete Separable Functions","text":"They all possess a similar interface and exist in three variants:","category":"page"},{"location":"separables/","page":"Concrete Separable Functions","title":"Concrete Separable Functions","text":"function_col:   collects data. This leads to an allocation of the result array, but is usually still faster then calculating the N-dimensional function directly at each position.\nfunction_lz:    a lazy version based on LazyArrays. This only allocates the one-dimensional memory for the values along each dimension. A lazy array can even avoid allocation if for example a sum over the array is performed. The array can also be used in broadcasting operations. However, currently it does not work using CUDA.jl-style CuArray objects.\nfunction_sep:   returns a calculated iterable of one-dimensional vectors (created using calculate_separables). They can then by multiplied (or summed) together using .*(res...) or alike, if res is the result of the function_sep call. This has the advantage of working also with CuArray datatypes, but in contrast to the function_lz Version, during a sum the array will be collected first and then summed.","category":"page"},{"location":"separables/","page":"Concrete Separable Functions","title":"Concrete Separable Functions","text":"gaussian_col\ngaussian_lz\ngaussian_sep\nnormal_col\nnormal_lz\nnormal_sep\nramp_col\nramp_lz\nramp_sep\nrr2_col\nrr2_lz\nrr2_sep\nbox_col\nbox_lz\nbox_sep\nsinc_col\nsinc_lz\nsinc_sep\nexp_ikx_col\nexp_ikx_lz\nexp_ikx_sep","category":"page"},{"location":"separables/#SeparableFunctions.gaussian_col","page":"Concrete Separable Functions","title":"SeparableFunctions.gaussian_col","text":"gaussian_col([::Type{TA},] sz::NTuple{N, Int}; sigma=ones(eltype(TA),N), pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}\n\ncreates a multidimensional Gaussian by exployting separability speeding up the calculation.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the _col version yields a collected array, the _lz version a LazyArray and the _sep version an iterable of one-dimensional but oriented arrays, which can be used via the .*(res...) syntax with res being the result of the _sep call.\n\nArguments\n\nTA:     optionally an array type can be supplied. The default is Array{Float32}\nsz:     size of the result array\npos:    position of the gaussian in relationship to the center defined by offset\noffset: center position of the array\n\nsigma:  tuple of standard-deviation along each dimensional\n\nreturns the collected N-dimensional array.\n\n#Example\n\njulia> pos = (1.1, 0.2); sigma = (0.5, 1.0);\njulia> my_gaussian = gaussian_col((6,5); sigma=sigma, pos=pos)\n6×5 Matrix{Float32}:\n    2.22857f-16  1.21991f-15  2.4566f-15   1.81989f-15  4.95978f-16\n    3.99823f-10  2.18861f-9   4.40732f-9   3.26502f-9   8.89822f-10\n    1.3138f-5    7.19168f-5   0.000144823  0.000107287  2.92392f-5\n    0.00790705   0.0432828    0.0871608    0.0645703    0.0175975\n    0.0871608    0.477114     0.960789     0.71177      0.19398\n    0.0175975    0.0963276    0.19398      0.143704     0.0391639\n\n\n\n\n\n","category":"function"},{"location":"separables/#SeparableFunctions.gaussian_lz","page":"Concrete Separable Functions","title":"SeparableFunctions.gaussian_lz","text":"gaussian_lz([::Type{TA},] sz::NTuple{N, Int}; sigma=ones(eltype(TA),N), pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}\n\ncreates a multidimensional Gaussian by exployting separability speeding up the calculation.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the _col version yields a collected array, the _lz version a LazyArray and the _sep version an iterable of one-dimensional but oriented arrays, which can be used via the .*(res...) syntax with res being the result of the _sep call.\n\nArguments\n\nTA:     optionally an array type can be supplied. The default is Array{Float32}\nsz:     size of the result array\npos:    position of the gaussian in relationship to the center defined by offset\noffset: center position of the array\n\nsigma:  tuple of standard-deviation along each dimensional\n\nreturns the a lazy version of an N-dimensional array only using memory for the separated 1-dimensional arrays. See the _col version for an example.\n\n\n\n\n\n","category":"function"},{"location":"separables/#SeparableFunctions.gaussian_sep","page":"Concrete Separable Functions","title":"SeparableFunctions.gaussian_sep","text":"gaussian_sep([::Type{TA},] sz::NTuple{N, Int}; sigma=ones(eltype(TA),N), pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}\n\ncreates a multidimensional Gaussian by exployting separability speeding up the calculation.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the _col version yields a collected array, the _lz version a LazyArray and the _sep version an iterable of one-dimensional but oriented arrays, which can be used via the .*(res...) syntax with res being the result of the _sep call.\n\nArguments\n\nTA:     optionally an array type can be supplied. The default is Array{Float32}\nsz:     size of the result array\npos:    position of the gaussian in relationship to the center defined by offset\noffset: center position of the array\n\nsigma:  tuple of standard-deviation along each dimensional\n\nreturns an iterable with the one-dimensional arrays, which can be used via .*(res...) wiht res being the result of calling this function.\n\n\n\n\n\n","category":"function"},{"location":"separables/#SeparableFunctions.normal_col","page":"Concrete Separable Functions","title":"SeparableFunctions.normal_col","text":"normal_col([::Type{TA},] sz::NTuple{N, Int}; sigma=ones(eltype(TA),N), pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}\n\ncreates a multidimensional normalized Gaussian by exployting separability speeding up the calculation. The integral of the multidimensional array, if it where infinite, is normalized to one.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the _col version yields a collected array, the _lz version a LazyArray and the _sep version an iterable of one-dimensional but oriented arrays, which can be used via the .*(res...) syntax with res being the result of the _sep call.\n\nArguments\n\nTA:     optionally an array type can be supplied. The default is Array{Float32}\nsz:     size of the result array\npos:    position of the gaussian in relationship to the center defined by offset\noffset: center position of the array\n\nsigma:  tuple of standard-deviation along each dimensional\n\nreturns the collected N-dimensional array. #Example\n\njulia> pos = (1.1, 0.2); sigma = (0.5, 1.0);\njulia> my_normal = normal_col((6,5); sigma=sigma, pos=pos)\n6×5 Matrix{Float32}:\n    7.09377f-17  3.88309f-16  7.81959f-16  5.79289f-16  1.57875f-16\n    1.27268f-10  6.96656f-10  1.40289f-9   1.03929f-9   2.83239f-10\n    4.18196f-6   2.28918f-5   4.60985f-5   3.41506f-5   9.30713f-6\n    0.00251689   0.0137773    0.0277442    0.0205534    0.00560145\n    0.0277442    0.15187      0.305829     0.226564     0.0617458\n    0.00560145   0.030662     0.0617458    0.0457424    0.0124663\n\n\n\n\n\n","category":"function"},{"location":"separables/#SeparableFunctions.normal_lz","page":"Concrete Separable Functions","title":"SeparableFunctions.normal_lz","text":"normal_lz([::Type{TA},] sz::NTuple{N, Int}; sigma=ones(eltype(TA),N), pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}\n\ncreates a multidimensional normalized Gaussian by exployting separability speeding up the calculation. The integral of the multidimensional array, if it where infinite, is normalized to one.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the _col version yields a collected array, the _lz version a LazyArray and the _sep version an iterable of one-dimensional but oriented arrays, which can be used via the .*(res...) syntax with res being the result of the _sep call.\n\nArguments\n\nTA:     optionally an array type can be supplied. The default is Array{Float32}\nsz:     size of the result array\npos:    position of the gaussian in relationship to the center defined by offset\noffset: center position of the array\n\nsigma:  tuple of standard-deviation along each dimensional\n\nreturns the a lazy version of an N-dimensional array only using memory for the separated 1-dimensional arrays. See the _col version for an example.\n\n\n\n\n\n","category":"function"},{"location":"separables/#SeparableFunctions.normal_sep","page":"Concrete Separable Functions","title":"SeparableFunctions.normal_sep","text":"normal_sep([::Type{TA},] sz::NTuple{N, Int}; sigma=ones(eltype(TA),N), pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}\n\ncreates a multidimensional normalized Gaussian by exployting separability speeding up the calculation. The integral of the multidimensional array, if it where infinite, is normalized to one.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the _col version yields a collected array, the _lz version a LazyArray and the _sep version an iterable of one-dimensional but oriented arrays, which can be used via the .*(res...) syntax with res being the result of the _sep call.\n\nArguments\n\nTA:     optionally an array type can be supplied. The default is Array{Float32}\nsz:     size of the result array\npos:    position of the gaussian in relationship to the center defined by offset\noffset: center position of the array\n\nsigma:  tuple of standard-deviation along each dimensional\n\nreturns an iterable with the one-dimensional arrays, which can be used via .*(res...) wiht res being the result of calling this function.\n\n\n\n\n\n","category":"function"},{"location":"separables/#SeparableFunctions.ramp_col","page":"Concrete Separable Functions","title":"SeparableFunctions.ramp_col","text":"ramp_col([::Type{TA},] sz::NTuple{N, Int}; slope, pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}\n\ncreates an N-dimensional ramp along the gradient-direction defined by slope. Note that this disagrees with the nomenclature of the ramp-function defined in IndexFunArrays.jl.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the _col version yields a collected array, the _lz version a LazyArray and the _sep version an iterable of one-dimensional but oriented arrays, which can be used via the .*(res...) syntax with res being the result of the _sep call.\n\nArguments\n\nTA:     optionally an array type can be supplied. The default is Array{Float32}\nsz:     size of the result array\npos:    position of the gaussian in relationship to the center defined by offset\noffset: center position of the array\n\nslope:  a vector defining the N-dimensional gradient of the ramp.\n\nreturns the collected N-dimensional array. #Example julia> myramp = rampcol((6,5); slope=(0.0,0.5), pos=pos) 6×5 Matrix{Float32}:  -1.1  -0.6  -0.1  0.4  0.9  -1.1  -0.6  -0.1  0.4  0.9  -1.1  -0.6  -0.1  0.4  0.9  -1.1  -0.6  -0.1  0.4  0.9  -1.1  -0.6  -0.1  0.4  0.9  -1.1  -0.6  -0.1  0.4  0.9 ```\n\n\n\n\n\n","category":"function"},{"location":"separables/#SeparableFunctions.ramp_lz","page":"Concrete Separable Functions","title":"SeparableFunctions.ramp_lz","text":"ramp_lz([::Type{TA},] sz::NTuple{N, Int}; slope, pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}\n\ncreates an N-dimensional ramp along the gradient-direction defined by slope. Note that this disagrees with the nomenclature of the ramp-function defined in IndexFunArrays.jl.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the _col version yields a collected array, the _lz version a LazyArray and the _sep version an iterable of one-dimensional but oriented arrays, which can be used via the .*(res...) syntax with res being the result of the _sep call.\n\nArguments\n\nTA:     optionally an array type can be supplied. The default is Array{Float32}\nsz:     size of the result array\npos:    position of the gaussian in relationship to the center defined by offset\noffset: center position of the array\n\nslope:  a vector defining the N-dimensional gradient of the ramp.\n\nreturns the a lazy version of an N-dimensional array only using memory for the separated 1-dimensional arrays. See the _col version for an example.\n\n\n\n\n\n","category":"function"},{"location":"separables/#SeparableFunctions.ramp_sep","page":"Concrete Separable Functions","title":"SeparableFunctions.ramp_sep","text":"ramp_sep([::Type{TA},] sz::NTuple{N, Int}; slope, pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}\n\ncreates an N-dimensional ramp along the gradient-direction defined by slope. Note that this disagrees with the nomenclature of the ramp-function defined in IndexFunArrays.jl.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the _col version yields a collected array, the _lz version a LazyArray and the _sep version an iterable of one-dimensional but oriented arrays, which can be used via the .*(res...) syntax with res being the result of the _sep call.\n\nArguments\n\nTA:     optionally an array type can be supplied. The default is Array{Float32}\nsz:     size of the result array\npos:    position of the gaussian in relationship to the center defined by offset\noffset: center position of the array\n\nslope:  a vector defining the N-dimensional gradient of the ramp.\n\nreturns an iterable with the one-dimensional arrays, which can be used via .*(res...) wiht res being the result of calling this function.\n\n\n\n\n\n","category":"function"},{"location":"separables/#SeparableFunctions.rr2_col","page":"Concrete Separable Functions","title":"SeparableFunctions.rr2_col","text":"rr2_col([::Type{TA},] sz::NTuple{N, Int}; pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}\n\nyields the absolute square of the distance to the zero-position.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the _col version yields a collected array, the _lz version a LazyArray and the _sep version an iterable of one-dimensional but oriented arrays, which can be used via the .*(res...) syntax with res being the result of the _sep call.\n\nArguments\n\nTA:     optionally an array type can be supplied. The default is Array{Float32}\nsz:     size of the result array\npos:    position of the gaussian in relationship to the center defined by offset\noffset: center position of the array\n\nreturns the collected N-dimensional array. #Example\n\njulia> pos = (1.1, 0.2); \njulia> my_rr2 = rr2_col((6,5); pos=pos)\n6×5 Matrix{Float32}:\n    21.65  18.25  16.85  17.45  20.05\n    14.45  11.05   9.65  10.25  12.85\n    9.25   5.85   4.45   5.05   7.65\n    6.05   2.65   1.25   1.85   4.45\n    4.85   1.45   0.05   0.65   3.25\n    5.65   2.25   0.85   1.45   4.05\n\n\n\n\n\n","category":"function"},{"location":"separables/#SeparableFunctions.rr2_lz","page":"Concrete Separable Functions","title":"SeparableFunctions.rr2_lz","text":"rr2_lz([::Type{TA},] sz::NTuple{N, Int}; pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}\n\nyields the absolute square of the distance to the zero-position.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the _col version yields a collected array, the _lz version a LazyArray and the _sep version an iterable of one-dimensional but oriented arrays, which can be used via the .*(res...) syntax with res being the result of the _sep call.\n\nArguments\n\nTA:     optionally an array type can be supplied. The default is Array{Float32}\nsz:     size of the result array\npos:    position of the gaussian in relationship to the center defined by offset\noffset: center position of the array\n\nreturns the a lazy version of an N-dimensional array only using memory for the separated 1-dimensional arrays. See the _col version for an example.\n\n\n\n\n\n","category":"function"},{"location":"separables/#SeparableFunctions.rr2_sep","page":"Concrete Separable Functions","title":"SeparableFunctions.rr2_sep","text":"rr2_sep([::Type{TA},] sz::NTuple{N, Int}; pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}\n\nyields the absolute square of the distance to the zero-position.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the _col version yields a collected array, the _lz version a LazyArray and the _sep version an iterable of one-dimensional but oriented arrays, which can be used via the .*(res...) syntax with res being the result of the _sep call.\n\nArguments\n\nTA:     optionally an array type can be supplied. The default is Array{Float32}\nsz:     size of the result array\npos:    position of the gaussian in relationship to the center defined by offset\noffset: center position of the array\n\nreturns an iterable with the one-dimensional arrays, which can be used via .+(res...) wiht res being the result of calling this function.\n\n\n\n\n\n","category":"function"},{"location":"separables/#SeparableFunctions.box_col","page":"Concrete Separable Functions","title":"SeparableFunctions.box_col","text":"box_col([::Type{TA},] sz::NTuple{N, Int}; boxsize=sz./2, pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}\n\ncreates a Boolean box, being True inside and False outside. The side-length of the box can be defined via the argument boxsize.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the _col version yields a collected array, the _lz version a LazyArray and the _sep version an iterable of one-dimensional but oriented arrays, which can be used via the .*(res...) syntax with res being the result of the _sep call.\n\nArguments\n\nTA:     optionally an array type can be supplied. The default is Array{Float32}\nsz:     size of the result array\npos:    position of the gaussian in relationship to the center defined by offset\noffset: center position of the array\n\nboxsize:  a vector defining each sidelength of the box.\n\nreturns the collected N-dimensional array. #Example\n\njulia> pos = (1.1, 0.2); \njulia> my_box = box_col((6,5); pos=pos)\n6×5 BitMatrix:\n 0  0  0  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n 0  1  1  1  0\n 0  1  1  1  0\n 0  1  1  1  0\n\n\n\n\n\n","category":"function"},{"location":"separables/#SeparableFunctions.box_lz","page":"Concrete Separable Functions","title":"SeparableFunctions.box_lz","text":"box_lz([::Type{TA},] sz::NTuple{N, Int}; boxsize=sz./2, pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}\n\ncreates a Boolean box, being True inside and False outside. The side-length of the box can be defined via the argument boxsize.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the _col version yields a collected array, the _lz version a LazyArray and the _sep version an iterable of one-dimensional but oriented arrays, which can be used via the .*(res...) syntax with res being the result of the _sep call.\n\nArguments\n\nTA:     optionally an array type can be supplied. The default is Array{Float32}\nsz:     size of the result array\npos:    position of the gaussian in relationship to the center defined by offset\noffset: center position of the array\n\nboxsize:  a vector defining each sidelength of the box.\n\nreturns the a lazy version of an N-dimensional array only using memory for the separated 1-dimensional arrays. See the _col version for an example.\n\n\n\n\n\n","category":"function"},{"location":"separables/#SeparableFunctions.box_sep","page":"Concrete Separable Functions","title":"SeparableFunctions.box_sep","text":"box_sep([::Type{TA},] sz::NTuple{N, Int}; boxsize=sz./2, pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}\n\ncreates a Boolean box, being True inside and False outside. The side-length of the box can be defined via the argument boxsize.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the _col version yields a collected array, the _lz version a LazyArray and the _sep version an iterable of one-dimensional but oriented arrays, which can be used via the .*(res...) syntax with res being the result of the _sep call.\n\nArguments\n\nTA:     optionally an array type can be supplied. The default is Array{Float32}\nsz:     size of the result array\npos:    position of the gaussian in relationship to the center defined by offset\noffset: center position of the array\n\nboxsize:  a vector defining each sidelength of the box.\n\nreturns an iterable with the one-dimensional arrays, which can be used via .*(res...) wiht res being the result of calling this function.\n\n\n\n\n\n","category":"function"},{"location":"separables/#SeparableFunctions.sinc_col","page":"Concrete Separable Functions","title":"SeparableFunctions.sinc_col","text":"sinc_col([::Type{TA},] sz::NTuple{N, Int}; pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}\n\nyields the outer product of sinc functions. This corresponds to the diffraction pattern of a rectangular aperture. Note that it is not circularly symmetric.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the _col version yields a collected array, the _lz version a LazyArray and the _sep version an iterable of one-dimensional but oriented arrays, which can be used via the .*(res...) syntax with res being the result of the _sep call.\n\nArguments\n\nTA:     optionally an array type can be supplied. The default is Array{Float32}\nsz:     size of the result array\npos:    position of the gaussian in relationship to the center defined by offset\noffset: center position of the array\n\nreturns the collected N-dimensional array. #Example\n\njulia> pos = (1.1, 0.2); \njulia> my_sinc = sinc_col((6,5); pos=pos)\n6×5 Matrix{Float32}:\n  0.0020403   -0.00374056   0.0224433   0.00561083  -0.0024937\n -0.00269847   0.00494719  -0.0296831  -0.00742078   0.00329812\n  0.00398345  -0.00730299   0.0438179   0.0109545   -0.00486866\n -0.00760477   0.0139421   -0.0836524  -0.0209131    0.00929472\n  0.0836524   -0.153363     0.920177    0.230044    -0.102242\n  0.00929472  -0.0170403    0.102242    0.0255605   -0.0113602\n\n\n\n\n\n","category":"function"},{"location":"separables/#SeparableFunctions.sinc_lz","page":"Concrete Separable Functions","title":"SeparableFunctions.sinc_lz","text":"sinc_lz([::Type{TA},] sz::NTuple{N, Int}; pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}\n\nyields the outer product of sinc functions. This corresponds to the diffraction pattern of a rectangular aperture. Note that it is not circularly symmetric.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the _col version yields a collected array, the _lz version a LazyArray and the _sep version an iterable of one-dimensional but oriented arrays, which can be used via the .*(res...) syntax with res being the result of the _sep call.\n\nArguments\n\nTA:     optionally an array type can be supplied. The default is Array{Float32}\nsz:     size of the result array\npos:    position of the gaussian in relationship to the center defined by offset\noffset: center position of the array\n\nreturns the a lazy version of an N-dimensional array only using memory for the separated 1-dimensional arrays. See the _col version for an example.\n\n\n\n\n\n","category":"function"},{"location":"separables/#SeparableFunctions.sinc_sep","page":"Concrete Separable Functions","title":"SeparableFunctions.sinc_sep","text":"sinc_sep([::Type{TA},] sz::NTuple{N, Int}; pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}\n\nyields the outer product of sinc functions. This corresponds to the diffraction pattern of a rectangular aperture. Note that it is not circularly symmetric.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the _col version yields a collected array, the _lz version a LazyArray and the _sep version an iterable of one-dimensional but oriented arrays, which can be used via the .*(res...) syntax with res being the result of the _sep call.\n\nArguments\n\nTA:     optionally an array type can be supplied. The default is Array{Float32}\nsz:     size of the result array\npos:    position of the gaussian in relationship to the center defined by offset\noffset: center position of the array\n\nreturns an iterable with the one-dimensional arrays, which can be used via .*(res...) wiht res being the result of calling this function.\n\n\n\n\n\n","category":"function"},{"location":"separables/#SeparableFunctions.exp_ikx_col","page":"Concrete Separable Functions","title":"SeparableFunctions.exp_ikx_col","text":"exp_ikx_col([::Type{TA},] sz::NTuple{N, Int}; pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}\n\nyield an exp.(1im .* k .* Δx) function. A scaling of one means that the shift_by argument corresponds to Δx in integer pixels, but the term is in Fourier space. Note that the meaning of scale is different compared to the version in IndexFunArray.jl. Here the default scaling of 1.0 corresponds to the default scaling of ScaFT in IndexFunArrays.jl.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the _col version yields a collected array, the _lz version a LazyArray and the _sep version an iterable of one-dimensional but oriented arrays, which can be used via the .*(res...) syntax with res being the result of the _sep call.\n\nArguments\n\nTA:     optionally an array type can be supplied. The default is Array{Float32}\nsz:     size of the result array\npos:    position of the gaussian in relationship to the center defined by offset\noffset: center position of the array\n\nshift_by:  a vector defining the real-space shift that would be caused by this function being multiplied in Fourier-space.\n\nreturns the collected N-dimensional array. #Example\n\njulia> pos = (1.1, 0.2); \njulia> my_exp_ikx = exp_ikx_col((6,5); shift_by=(1.0,0.0), pos=pos)\n6×5 Matrix{ComplexF32}:\n -0.406737-0.913545im  -0.406737-0.913545im  -0.406737-0.913545im  -0.406737-0.913545im  -0.406737-0.913545im\n -0.994522-0.104528im  -0.994522-0.104528im  -0.994522-0.104528im  -0.994522-0.104528im  -0.994522-0.104528im\n -0.587785+0.809017im  -0.587785+0.809017im  -0.587785+0.809017im  -0.587785+0.809017im  -0.587785+0.809017im\n  0.406737+0.913545im   0.406737+0.913545im   0.406737+0.913545im   0.406737+0.913545im   0.406737+0.913545im\n  0.994522+0.104528im   0.994522+0.104528im   0.994522+0.104528im   0.994522+0.104528im   0.994522+0.104528im\n  0.587785-0.809017im   0.587785-0.809017im   0.587785-0.809017im   0.587785-0.809017im   0.587785-0.809017im\n\n\n\n\n\n","category":"function"},{"location":"separables/#SeparableFunctions.exp_ikx_lz","page":"Concrete Separable Functions","title":"SeparableFunctions.exp_ikx_lz","text":"exp_ikx_lz([::Type{TA},] sz::NTuple{N, Int}; pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}\n\ncreates a Boolean box, being True inside and False outside. The side-length of the box can be defined via the argument boxsize.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the _col version yields a collected array, the _lz version a LazyArray and the _sep version an iterable of one-dimensional but oriented arrays, which can be used via the .*(res...) syntax with res being the result of the _sep call.\n\nArguments\n\nTA:     optionally an array type can be supplied. The default is Array{Float32}\nsz:     size of the result array\npos:    position of the gaussian in relationship to the center defined by offset\noffset: center position of the array\n\nshift_by:  a vector defining the real-space shift that would be caused by this function being multiplied in Fourier-space.\n\nreturns the a lazy version of an N-dimensional array only using memory for the separated 1-dimensional arrays. See the _col version for an example.\n\n\n\n\n\n","category":"function"},{"location":"separables/#SeparableFunctions.exp_ikx_sep","page":"Concrete Separable Functions","title":"SeparableFunctions.exp_ikx_sep","text":"exp_ikx_sep([::Type{TA},] sz::NTuple{N, Int}; pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}\n\nyield an exp.(1im .* k .* Δx) function. A scaling of one means that the shift_by argument corresponds to Δx in integer pixels, but the term is in Fourier space. Note that the meaning of scale is different compared to the version in IndexFunArray.jl. Here the default scaling of 1.0 corresponds to the default scaling of ScaFT in IndexFunArrays.jl.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the _col version yields a collected array, the _lz version a LazyArray and the _sep version an iterable of one-dimensional but oriented arrays, which can be used via the .*(res...) syntax with res being the result of the _sep call.\n\nArguments\n\nTA:     optionally an array type can be supplied. The default is Array{Float32}\nsz:     size of the result array\npos:    position of the gaussian in relationship to the center defined by offset\noffset: center position of the array\n\nshift_by:  a vector defining the real-space shift that would be caused by this function being multiplied in Fourier-space.\n\nreturns an iterable with the one-dimensional arrays, which can be used via .*(res...) wiht res being the result of calling this function.\n\n\n\n\n\n","category":"function"},{"location":"radial/#Radial-functions","page":"Radial Functions","title":"Radial functions","text":"","category":"section"},{"location":"radial/","page":"Radial Functions","title":"Radial Functions","text":"These functions are purely radial, in which case only a quadrant is computed and then copied. They are all based on a separable view version of rr2 but then continue to calculate on a corner of a grid, which is (as a last step) replicated and mirrored.","category":"page"},{"location":"radial/","page":"Radial Functions","title":"Radial Functions","text":"calc_radial_symm\ncalc_radial_symm!\npropagator_col\npropagator_col!\nphase_kz_col\nphase_kz_col!","category":"page"},{"location":"radial/#SeparableFunctions.calc_radial_symm","page":"Radial Functions","title":"SeparableFunctions.calc_radial_symm","text":"calc_radial_symm!([::Type{TA},] sz::NTuple,  fct; scale = one(real(T)), myrr2sep = rr2_sep(size(arr); scale=scale, offset=size(arr).÷2 .+1)) where {N,T}\n\nevaluates the radial function fct over the entire array. The function needs to accept the radius as argument. The calculation is done fast by only evaluating on the first quadrant and replicating the results by copy operations using copy_corners!().\n\n#Arguments\n\nTA:         The array type for the newly created array. \nsz:         The size of the newly created array. \nfct:        The function of the radius, to be evaluate on the array coordinates. \nscale:      the vetorized scaling of the pixels (only used, if myrr2sep is not supplied by the user)\nmyrr2sep:   The separable xx^2 and yy^2 etc. information as obtained by rr2_sep().\n\n\n\n\n\n","category":"function"},{"location":"radial/#SeparableFunctions.calc_radial_symm!","page":"Radial Functions","title":"SeparableFunctions.calc_radial_symm!","text":"calc_radial_symm!(arr::TA, fct; scale = one(real(T)), myrr2sep = rr2_sep(size(arr); scale=scale, offset=size(arr).÷2 .+1)) where {N,T}\n\nevaluates the radial function fct over the entire array. The function needs to accept the radius as argument. The calculation is done fast by only evaluating on the first quadrant and replicating the results by copy operations using copy_corners!().\n\n#Arguments\n\narr:    The array into which to evaluate the radial function \nfct:        The function of the radius, to be evaluate on the array coordinates. \nscale:      the vetorized scaling of the pixels (only used, if myrr2sep is not supplied by the user)\nmyrr2sep:   The separable xx^2 and yy^2 etc. information as obtained by rr2_sep().\n\n\n\n\n\n","category":"function"},{"location":"radial/#SeparableFunctions.propagator_col","page":"Radial Functions","title":"SeparableFunctions.propagator_col","text":"propagator_col([]::Type{TA},] sz::NTuple{N, Int}; Δz=one(eltype(TA)), k_max=0.5f0, scale=0.5f0 ./ (max.(sz ./ 2, 1))) where{TA, N}\n\ngenerates a propagator for propagating optical fields via exp(i kz Δz) with kz=sqrt(k0^2-kx^2-ky^2). The k-space radius is stated by k_max relative to the Nyquist frequency, as long as the scale remains to be 1 ./ (2 max.(sz ./ 2, 1))).\n\n#Arguments\n\nTA:     type of the array to generate. E.g. Array{Float64} or CuArray{Float32}.\nsz:     size of the array to generate.  If a 3rd dimension is present, a stack a propagators is returned, one for each multiple of Δz.\nΔz:     distance in Z to propagate per slice.\nk_max:  maximum propagation radius in k-space. I.e. limit of the k-sphere. This is not the aperture limit!\nscale:  specifies how to interpret k-space positions. Should remain to be 1 ./ (2 max.(sz ./ 2, 1))).\n\n\n\n\n\n","category":"function"},{"location":"radial/#SeparableFunctions.propagator_col!","page":"Radial Functions","title":"SeparableFunctions.propagator_col!","text":"propagator_col(arr::AbstractArray{T,N}; Δz=one(eltype(TA)), k_max=0.5f0, scale=0.5f0 ./ (max.(sz ./ 2, 1))) where{TA, N}\n\ngenerates a propagator for propagating optical fields via exp(i kz Δz) with kz=sqrt(k0^2-kx^2-ky^2). The k-space radius is stated by k_max relative to the Nyquist frequency, as long as the scale remains to be 1 ./ (2 max.(sz ./ 2, 1))).\n\n#Arguments\n\narr:    the array to fill with propagators. If a 3rd dimension is present, a stack a propagators is returned, one for each multiple of Δz.\nΔz:     distance in Z to propagate per slice.\nk_max:  maximum propagation radius in k-space. I.e. limit of the k-sphere. This is not the aperture limit!\nscale:  specifies how to interpret k-space positions. Should remain to be 1 ./ (2 max.(sz ./ 2, 1))).\n\n\n\n\n\n","category":"function"},{"location":"radial/#SeparableFunctions.phase_kz_col","page":"Radial Functions","title":"SeparableFunctions.phase_kz_col","text":"phase_kz_col([::Type{TA},] sz::NTuple{N, Int};k_max=0.5f0, scale=0.5f0 ./ (max.(sz ./ 2, 1))) where{TA, N}\n\nCalculates a propagation phase (without the 2pi factor!) for a given z-position, which can be defined via a 3rd entry in the offset supplied to the function. By default, Nyquist sampling it is assumed such that the lateral kxy corresponds to the XY border in frequency space at the edge  of the Ewald circle. However, via the xy scale entries the kmax can be set appropriately. The propagation equation should Δz .* sqrt.(1-kxyrel^2) as the propagation phase. The Z-propagation distance (Δz) has to be specified in  units of the wavelength in the medium (λ = n*λ₀). Note that since the phase is normalized to 1 instead of 2pi, you need to use this phase in the following sense: `cispi.(2.*phasekz(...))`.\n\n#Arguments\n\nTA:     Array type of the result array. For cuda calculations use CuArray{Float32}.\nsz:     Size (2D) of the result array. \nk_max:  maximum propagation radius in k-space. I.e. limit of the k-sphere. This is not the aperture limit!\nscale:  specifies how to interpret k-space positions. Should remain to be 1 ./ (2 max.(sz ./ 2, 1))).\n\n\n\n\n\n","category":"function"},{"location":"radial/#SeparableFunctions.phase_kz_col!","page":"Radial Functions","title":"SeparableFunctions.phase_kz_col!","text":"phase_kz_col!(arr::AbstractArray{T,N}; k_max=0.5f0, scale=0.5f0 ./ (max.(sz ./ 2, 1))) where{TA, N}\n\nCalculates a propagation phase (without the 2pi factor!) for a given z-position, which can be defined via a 3rd entry in the offset supplied to the function. By default, Nyquist sampling it is assumed such that the lateral kxy corresponds to the XY border in frequency space at the edge  of the Ewald circle. However, via the xy scale entries the kmax can be set appropriately. The propagation equation uses Δz .* sqrt.(1-kxyrel^2) as the propagation phase. The Z-propagation distance (Δz) has to be specified in  units of the wavelength in the medium (λ = n*λ₀). Note that since the phase is normalized to 1 instead of 2pi, you need to use this phase in the following sense: `cispi.(2.*phasekz(...))`.\n\n#Arguments\n\narr:    the array to fill with propagators. If a 3rd dimension is present, a stack a propagators is returned, one for each multiple of Δz.\nk_max:  maximum propagation radius in k-space. I.e. limit of the k-sphere. This is not the aperture limit!\nscale:  specifies how to interpret k-space positions. Should remain to be 1 ./ (2 max.(sz ./ 2, 1))).\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Utility-functions","page":"Utilities","title":"Utility functions","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Helper functions","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"SeparableFunctions.arg_n\nSeparableFunctions.kwarg_n\nSeparableFunctions.pick_n\nSeparableFunctions.get_corner_ranges\nSeparableFunctions.copy_last_dim!\nSeparableFunctions.similar_arr_type\nSeparableFunctions.get_real_arr_type","category":"page"},{"location":"utilities/#SeparableFunctions.arg_n","page":"Utilities","title":"SeparableFunctions.arg_n","text":"arg_n(n, args...)\n\nreturns a modified version of args, such that scalars remain scalar but in vectors the n'th position is picked. This is useful for calling separable functions with their scalar arguments differing for each vector entry. \n\nExample\n\njdoctest julia> args = (1,(4,5)) (1, (4, 5)) julia> collect(SeparableFunctions.arg_n(2, args)) 2-element Vector{Int64}:  1  5\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SeparableFunctions.kwarg_n","page":"Utilities","title":"SeparableFunctions.kwarg_n","text":"kwarg_n(n, args...)\n\nreturns a modified version of keyword-args kwargs, such that scalar values remain scalar but in vectors the n'th position is picked. This is useful for calling separable functions with their scalar arguments differing for each vector entry. \n\n# Example\n\njulia> kw = (a=1,b=(4,5))\n(a = 1, b = (4, 5))\njulia> SeparableFunctions.kwarg_n(2, kw)\n(a = 1, b = 5)\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SeparableFunctions.pick_n","page":"Utilities","title":"SeparableFunctions.pick_n","text":"pick_n(n, v)\n\npicks the nth value of the vector v or the scalar v.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SeparableFunctions.get_corner_ranges","page":"Utilities","title":"SeparableFunctions.get_corner_ranges","text":"get_corner_ranges(sz::NTuple{N}; shifted_dims = zeros(Bool, N), inv_dims = zeros(Bool, N), full_dims=zeros(Bool, N)) where {N}\n\nreturns a tuple of ranges that can be used for indexing various corners of an N-dimensional dataset. #Arguments\n\nsz:     total size of the data\nshifted_dims:   an iterable of Boolean defining which dimension to shift (by half the datasize)\ninv_dims:       an iterable of Boolean defining which which range dimension\nfull_dims:      an iterable of Boolean defining which dimension to include fully as a colon (:)\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SeparableFunctions.copy_last_dim!","page":"Utilities","title":"SeparableFunctions.copy_last_dim!","text":"copy_last_dim(arr::AbstractArray{T,N}) where{T,N}\n\nmirrors the last dimension exploiting the 1D-nature of the trailing dimension using 1D indexing of the ND array. However even-size dimensions need special treatment.\n\n\n\n\n\n","category":"function"},{"location":"#SeparableFunctions.jl","page":"SeparableFunctions.jl","title":"SeparableFunctions.jl","text":"","category":"section"},{"location":"#SeparableFunctions.jl-Interface","page":"SeparableFunctions.jl","title":"SeparableFunctions.jl Interface","text":"","category":"section"},{"location":"","page":"SeparableFunctions.jl","title":"SeparableFunctions.jl","text":"General information","category":"page"},{"location":"","page":"SeparableFunctions.jl","title":"SeparableFunctions.jl","text":"SeparableFunctions","category":"page"},{"location":"#SeparableFunctions","page":"SeparableFunctions.jl","title":"SeparableFunctions","text":"Calculates multidimensional functions faster by exploiting their separability. Often a function involves an operation such as a (complex) exponential which by itself is computationally relatively heavy. Yet a number of multidimenstional functions are separable, which means that they can be written as a product (or sum) of single-dimensional functions. A good example of a separable function is a Gaussian function, which can be written as a product of a purely X-dependend Gaussian with a purely Y-dependend Gaussian.\n\nIn this package, multidimensional functions are computed by first calculating their single-dimensional values and then creating the final multidimensional result by an outer product. Since multiplications and the broadcasting mechanism of Julia are fast compared to the evaluation of the function at each multidimensional position, the final result is calculated faster. The typical speedup can be an order of magnitude.\n\nThe package offers a general way of calculating separable functions as well as a LazyArrays version of that function which can then be used inside other expressions. The non-lazy version should currently also work with CUDA.jl, however the LazyArrays version does not. To nevertheless use separable expressions in CUDA.jl, you can reside to externally applying the broadcast operator to the separable expression (see the gaussian_sep example below).\n\nThe package further offers a number of predifined separable function implementations such as gaussian_col() collects a multidimensional array of a multidimensional Gaussian via a fast seperable implementation, gaussian_lz() yields a lazy representation via LazyArrays and sep = gaussian_sep() yields an iterable of separable pre-oriented vectors which can easily be mutually combined via .*(sep...).\n\nAnother noteworthy example is the complex plain wave as represented by the respective function exp_ikx_col(), exp_ikx_lz(), exp_ikx_sep().\n\nAll separable functions share a common interface with Standard non-named arguments\n\nthe first optional argument being the type of the result array. Examples are Array{Float64}, CuArray{Float32} and the default depends on the function but uses a 32-bit result type where applicable.\nthe next argument is the size of the result data supplied as a tuple.\noptionally a further argument can specify the position of zero of the array with respect to offset as given below. This allows for convenient N-dimensional shifting of the functions. \n\nNamed arguments:\n\noffset: is a optional named argument specifying center of the array. By default the Fourier center, size().÷2 .+ 1 is chosen.\nscale: multiplies the axes with these factors. This can be interpreted as a pixelsize.\n\nSome functions have additional named arguments. E.g. gaussian has the additional named argument sigma specifying the width of the gaussian, even though this can also be controlled via scale.  Note that this nomenclature is in large parts identical to the package IndexFunArrays.jl.\n\nIn general arguments can be supplied as single scalar values or vectors. If a scalar value is supplied, it will automatically be replicated as a vector. E.g. sigma=10.0 for a  2-dimensional array will be interpreted as sigma=(10.0, 10.0).\n\n\n\n\n\n","category":"module"},{"location":"#Generic-Ways-to-Create-Seperable-and-Radial-Functions","page":"SeparableFunctions.jl","title":"Generic Ways to Create Seperable and Radial Functions","text":"","category":"section"},{"location":"","page":"SeparableFunctions.jl","title":"SeparableFunctions.jl","text":"calculate_separables\nseparable_view\nseparable_create\ncopy_corners!","category":"page"},{"location":"#SeparableFunctions.calculate_separables","page":"SeparableFunctions.jl","title":"SeparableFunctions.calculate_separables","text":"calculate_separables([::Type{AT},] fct, sz::NTuple{N, Int}, args...; pos=zero(real(eltype(AT))), offset=sz.÷2 .+1, scale=one(real(eltype(AT))), kwargs...) where {AT, N}\n\ncreates a list of one-dimensional vectors, which can be combined to yield a separable array. In a way this can be seen as a half-way Lazy operation. The (potentially heavy) work of calculating the one-dimensional functions is done now but the memory-heavy calculation of the array is done later. This function is used in separable_view and separable_create.\n\n#Arguments\n\nAT:     optional type signfying the array result type. You can for example use CuArray{Float32} using CUDA to create the views on the GPU.\nfct:    the function to calculate for each axis index (no need for broadcasting!) of this iterable of seperable axes. Note that the first arguments of fct have to be the index of this coordinate and the size of this axis. Any further args and nargs can follow. Often the second argument is not used but it still needs to be present.\nsz:     the size of the result array (when appying the one-D axes)\nargs:   further arguments which are passed over to the function fct.\npos:    a position shifting the indices passed to fct in relationship to the offset.\noffset: specifying the center (zero-position) of the result array in one-based coordinates. The default corresponds to the Fourier-center.\nscale:  multiplies the index before passing it to fct\n\n#Example:\n\njulia> fct = (r, sz, sigma)-> exp(-r^2/(2*sigma^2))\njulia> gauss_sep = calculate_separables(fct, (6,5), (0.5,1.0), pos = (0.1,0.2))\n2-element Vector{Array{Float32}}:\n [4.4963495f-9; 0.00014774836; … ; 0.1978987; 0.0007318024;;]\n [0.088921614 0.48675224 … 0.726149 0.1978987]\n julia> my_gaussian = .*(gauss_sep...) # this is how to broadcast it\n 6×5 Matrix{Float32}:\n 3.99823f-10  2.18861f-9   4.40732f-9   3.26502f-9   8.89822f-10\n 1.3138f-5    7.19168f-5   0.000144823  0.000107287  2.92392f-5\n 0.00790705   0.0432828    0.0871608    0.0645703    0.0175975\n 0.0871608    0.477114     0.960789     0.71177      0.19398\n 0.0175975    0.0963276    0.19398      0.143704     0.0391639\n 6.50731f-5   0.000356206  0.000717312  0.000531398  0.000144823\n\n\n\n\n\n","category":"function"},{"location":"#SeparableFunctions.separable_view","page":"SeparableFunctions.jl","title":"SeparableFunctions.separable_view","text":"separable_view{N}(fct, sz, args...; pos=zero(real(eltype(AT))), offset =  sz.÷2 .+1, scale = one(real(eltype(AT))), operation = .*)\n\ncreates an array view of an N-dimensional separable function. Note that this view consumes much less memory than a full allocation of the collected result. Note also that an N-dimensional calculation expression may be much slower than this view reprentation of a product of N one-dimensional arrays. See the example below.\n\nArguments:\n\nfct:          The separable function, with a number of arguments corresponding to length(args), each corresponding to a vector of separable inputs of length N.                 The first argument of this function is a Tuple corresponding the centered indices.\nsz:           The size of the N-dimensional array to create\nargs...:      a list of arguments, each being an N-dimensional vector\noffset:       position of the center from which the position is measured\nscale:        defines the pixel size as vector or scalar. Default: 1.0.\noperation:    the separable operation connecting the separable dimensions\n\nExample:\n\njulia> fct = (r, sz, pos, sigma)-> exp(-(r-pos)^2/(2*sigma^2))\njulia> my_gaussian = separable_view(fct, (6,5), (0.1,0.2), (0.5,1.0))\n(6×1 Matrix{Float32}) .* (1×5 Matrix{Float32}):\n 3.99823e-10  2.18861e-9   4.40732e-9   3.26502e-9   8.89822e-10\n 1.3138e-5    7.19168e-5   0.000144823  0.000107287  2.92392e-5\n 0.00790705   0.0432828    0.0871609    0.0645703    0.0175975\n 0.0871609    0.477114     0.960789     0.71177      0.19398\n 0.0175975    0.0963276    0.19398      0.143704     0.0391639\n 6.50731e-5   0.000356206  0.000717312  0.000531398  0.000144823\n\n\n\n\n\n","category":"function"},{"location":"#SeparableFunctions.separable_create","page":"SeparableFunctions.jl","title":"SeparableFunctions.separable_create","text":"separable_create([::Type{TA},] fct, sz::NTuple{N, Int}, args...; pos=zero(real(eltype(AT))), offset =  sz.÷2 .+1, scale = one(real(eltype(AT))), operation = *, kwargs...) where {TA, N}\n\ncreates an array view of an N-dimensional separable function including memory allocation and collection. See the example below.\n\nArguments:\n\nfct:          The separable function, with a number of arguments corresponding to length(args), each corresponding to a vector of separable inputs of length N.                 The first argument of this function is a Tuple corresponding the centered indices.\nsz:           The size of the N-dimensional array to create\nargs...:      a list of arguments, each being an N-dimensional vector\noffset:       position of the center from which the position is measured\nscale:        defines the pixel size as vector or scalar. Default: 1.0.\noperation:    the separable operation connecting the separable dimensions\n\nExample:\n\njulia> fct = (r, sz, sigma)-> exp(-r^2/(2*sigma^2))\njulia> my_gaussian = separable_create(fct, (6,5), (0.5,1.0); pos=(0.1,0.2))\n6×5 Matrix{Float32}:\n 3.99823f-10  2.18861f-9   4.40732f-9   3.26502f-9   8.89822f-10\n 1.3138f-5    7.19168f-5   0.000144823  0.000107287  2.92392f-5\n 0.00790705   0.0432828    0.0871608    0.0645703    0.0175975\n 0.0871608    0.477114     0.960789     0.71177      0.19398\n 0.0175975    0.0963276    0.19398      0.143704     0.0391639\n 6.50731f-5   0.000356206  0.000717312  0.000531398  0.000144823\n\n\n\n\n\n","category":"function"},{"location":"#SeparableFunctions.copy_corners!","page":"SeparableFunctions.jl","title":"SeparableFunctions.copy_corners!","text":"copy_corners!(arr::AbstractArray{T,N}) where {T,N}\n\nreplicates the first N-dimensional quadrant my several mirror operations over the entire array. The overwrites the entire array with the (mirrored) content of the first quadrant!\n\n#Arguments\n\narr:    The array in which the copy operations are performed\nspeedup_last_dim=true:  if true a one-dimensional assignment trick is used for the last non-singleton dimension.\n\n\n\n\n\n","category":"function"}]
}
