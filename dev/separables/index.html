<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Concrete Separable Functions · SeparableFunctions.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SeparableFunctions.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">SeparableFunctions.jl</a></li><li class="is-active"><a class="tocitem" href>Concrete Separable Functions</a></li><li><a class="tocitem" href="../radial/">Radial Functions</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Concrete Separable Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Concrete Separable Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/master/docs/src/separables.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Concrete-SeparableFunctions"><a class="docs-heading-anchor" href="#Concrete-SeparableFunctions">Concrete SeparableFunctions</a><a id="Concrete-SeparableFunctions-1"></a><a class="docs-heading-anchor-permalink" href="#Concrete-SeparableFunctions" title="Permalink"></a></h1><p>They all possess a similar interface and exist in three variants:</p><ul><li>(recommended:) <code>function_sep</code>:   returns a broadcasted object, which is an operator combined with a calculated iterable of one-dimensional vectors (created using <code>calculate_separables</code>). This looks a lot like an array in terms of usage, yet it consumes far less memory and saves time when used in combination with other arrays. It also works with <code>CuArray</code> datatypes (provide the Array type as a first argument). Note that reduce operations about specific dimensions do not work directly on these objects but (currently) you need to call <code>collect</code> on it before applying for example<code>sum(collect(my_sep_object), dims=2)</code>.</li><li><code>function_col</code>:   collects data. This leads to an allocation of the result array, but is usually still faster then calculating the N-dimensional function directly at each position. Internally, it calls the <code>function_sep</code> mechanism described below, which is for most applications preferable.</li><li><code>function_lz</code>:    a lazy version based on <code>LazyArrays</code>. This only allocates the one-dimensional memory for the values along each dimension. A lazy array can even avoid allocation if for example a sum over the array is performed. The array can also be used in broadcasting operations. However, currently it does not work using <code>CUDA.jl</code>-style <code>CuArray</code> objects. This version is not recommended and not exported by the module.</li></ul><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.gaussian_sep" href="#SeparableFunctions.gaussian_sep"><code>SeparableFunctions.gaussian_sep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gaussian_sep([::Type{TA},] sz::NTuple{N, Int}; sigma=ones(eltype(TA),N), pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>creates a multidimensional Gaussian by exployting separability speeding up the calculation.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><ul><li><code>sigma</code>:  tuple of standard-deviation along each dimensional</li></ul><p>returns an iterable with the one-dimensional arrays, which can be used via <code>.*(res...)</code> wiht <code>res</code> being the result of calling this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/5bbfed019bc2376b86652d2031862d9e4b1d0c96/src/docstrings.jl#L54-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.gaussian_col" href="#SeparableFunctions.gaussian_col"><code>SeparableFunctions.gaussian_col</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gaussian_col([::Type{TA},] sz::NTuple{N, Int}; sigma=ones(eltype(TA),N), pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>creates a multidimensional Gaussian by exployting separability speeding up the calculation.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><ul><li><code>sigma</code>:  tuple of standard-deviation along each dimensional</li></ul><p>returns the collected N-dimensional array.</p><p>#Example</p><pre><code class="language-julia-repl">julia&gt; pos = (1.1, 0.2); sigma = (0.5, 1.0);
julia&gt; my_gaussian = gaussian_col((6,5); sigma=sigma, pos=pos)
6×5 Matrix{Float32}:
    2.22857f-16  1.21991f-15  2.4566f-15   1.81989f-15  4.95978f-16
    3.99823f-10  2.18861f-9   4.40732f-9   3.26502f-9   8.89822f-10
    1.3138f-5    7.19168f-5   0.000144823  0.000107287  2.92392f-5
    0.00790705   0.0432828    0.0871608    0.0645703    0.0175975
    0.0871608    0.477114     0.960789     0.71177      0.19398
    0.0175975    0.0963276    0.19398      0.143704     0.0391639</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/5bbfed019bc2376b86652d2031862d9e4b1d0c96/src/docstrings.jl#L21-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.normal_sep" href="#SeparableFunctions.normal_sep"><code>SeparableFunctions.normal_sep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normal_sep([::Type{TA},] sz::NTuple{N, Int}; sigma=ones(eltype(TA),N), pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>creates a multidimensional normalized Gaussian by exployting separability speeding up the calculation. The integral of the multidimensional array, if it where infinite, is normalized to one.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><ul><li><code>sigma</code>:  tuple of standard-deviation along each dimensional</li></ul><p>returns an iterable with the one-dimensional arrays, which can be used via <code>.*(res...)</code> wiht <code>res</code> being the result of calling this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/5bbfed019bc2376b86652d2031862d9e4b1d0c96/src/docstrings.jl#L98-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.normal_col" href="#SeparableFunctions.normal_col"><code>SeparableFunctions.normal_col</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normal_col([::Type{TA},] sz::NTuple{N, Int}; sigma=ones(eltype(TA),N), pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>creates a multidimensional normalized Gaussian by exployting separability speeding up the calculation. The integral of the multidimensional array, if it where infinite, is normalized to one.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><ul><li><code>sigma</code>:  tuple of standard-deviation along each dimensional</li></ul><p>returns the collected N-dimensional array. #Example</p><pre><code class="language-julia-repl">julia&gt; pos = (1.1, 0.2); sigma = (0.5, 1.0);
julia&gt; my_normal = normal_col((6,5); sigma=sigma, pos=pos)
6×5 Matrix{Float32}:
    7.09377f-17  3.88309f-16  7.81959f-16  5.79289f-16  1.57875f-16
    1.27268f-10  6.96656f-10  1.40289f-9   1.03929f-9   2.83239f-10
    4.18196f-6   2.28918f-5   4.60985f-5   3.41506f-5   9.30713f-6
    0.00251689   0.0137773    0.0277442    0.0205534    0.00560145
    0.0277442    0.15187      0.305829     0.226564     0.0617458
    0.00560145   0.030662     0.0617458    0.0457424    0.0124663</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/5bbfed019bc2376b86652d2031862d9e4b1d0c96/src/docstrings.jl#L66-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.ramp_sep" href="#SeparableFunctions.ramp_sep"><code>SeparableFunctions.ramp_sep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ramp_sep([::Type{TA},] sz::NTuple{N, Int}; slope, pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>creates an N-dimensional ramp along the gradient-direction defined by <code>slope</code>. Note that this disagrees with the nomenclature of the ramp-function defined in <code>IndexFunArrays.jl</code>.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><ul><li><code>slope</code>:  a vector defining the N-dimensional gradient of the ramp.</li></ul><p>returns an iterable with the one-dimensional arrays, which can be used via <code>.*(res...)</code> wiht <code>res</code> being the result of calling this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/5bbfed019bc2376b86652d2031862d9e4b1d0c96/src/docstrings.jl#L264-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.ramp_col" href="#SeparableFunctions.ramp_col"><code>SeparableFunctions.ramp_col</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ramp_col([::Type{TA},] sz::NTuple{N, Int}; slope, pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>creates an N-dimensional ramp along the gradient-direction defined by <code>slope</code>. Note that this disagrees with the nomenclature of the ramp-function defined in <code>IndexFunArrays.jl</code>.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><ul><li><code>slope</code>:  a vector defining the N-dimensional gradient of the ramp.</li></ul><p>returns the collected N-dimensional array. #Example julia&gt; my<em>ramp = ramp</em>col((6,5); slope=(0.0,0.5), pos=pos) 6×5 Matrix{Float32}:  -1.1  -0.6  -0.1  0.4  0.9  -1.1  -0.6  -0.1  0.4  0.9  -1.1  -0.6  -0.1  0.4  0.9  -1.1  -0.6  -0.1  0.4  0.9  -1.1  -0.6  -0.1  0.4  0.9  -1.1  -0.6  -0.1  0.4  0.9 ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/5bbfed019bc2376b86652d2031862d9e4b1d0c96/src/docstrings.jl#L234-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.rr2_sep" href="#SeparableFunctions.rr2_sep"><code>SeparableFunctions.rr2_sep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rr2_sep([::Type{TA},] sz::NTuple{N, Int}; pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>yields the absolute square of the distance to the zero-position.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><p>returns an iterable with the one-dimensional arrays, which can be used via <code>.+(res...)</code> wiht <code>res</code> being the result of calling this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/5bbfed019bc2376b86652d2031862d9e4b1d0c96/src/docstrings.jl#L139-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.rr2_col" href="#SeparableFunctions.rr2_col"><code>SeparableFunctions.rr2_col</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rr2_col([::Type{TA},] sz::NTuple{N, Int}; pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>yields the absolute square of the distance to the zero-position.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><p>returns the collected N-dimensional array. #Example</p><pre><code class="language-julia-repl">julia&gt; pos = (1.1, 0.2); 
julia&gt; my_rr2 = rr2_col((6,5); pos=pos)
6×5 Matrix{Float32}:
    21.65  18.25  16.85  17.45  20.05
    14.45  11.05   9.65  10.25  12.85
    9.25   5.85   4.45   5.05   7.65
    6.05   2.65   1.25   1.85   4.45
    4.85   1.45   0.05   0.65   3.25
    5.65   2.25   0.85   1.45   4.05</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/5bbfed019bc2376b86652d2031862d9e4b1d0c96/src/docstrings.jl#L111-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.box_sep" href="#SeparableFunctions.box_sep"><code>SeparableFunctions.box_sep</code></a> — <span class="docstring-category">Function</span></header><section><div><p>box_sep([::Type{TA},] sz::NTuple{N, Int}; boxsize=sz./2, pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</p><p>creates a Boolean box, being True inside and False outside. The side-length of the box can be defined via the argument <code>boxsize</code>.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><ul><li><code>boxsize</code>:  a vector defining each sidelength of the box.</li></ul><p>returns an iterable with the one-dimensional arrays, which can be used via <code>.*(res...)</code> wiht <code>res</code> being the result of calling this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/5bbfed019bc2376b86652d2031862d9e4b1d0c96/src/docstrings.jl#L221-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.box_col" href="#SeparableFunctions.box_col"><code>SeparableFunctions.box_col</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">box_col([::Type{TA},] sz::NTuple{N, Int}; boxsize=sz./2, pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>creates a Boolean box, being True inside and False outside. The side-length of the box can be defined via the argument <code>boxsize</code>.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><ul><li><code>boxsize</code>:  a vector defining each sidelength of the box.</li></ul><p>returns the collected N-dimensional array. #Example</p><pre><code class="language-julia-repl">julia&gt; pos = (1.1, 0.2); 
julia&gt; my_box = box_col((6,5); pos=pos)
6×5 BitMatrix:
 0  0  0  0  0
 0  0  0  0  0
 0  0  0  0  0
 0  1  1  1  0
 0  1  1  1  0
 0  1  1  1  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/5bbfed019bc2376b86652d2031862d9e4b1d0c96/src/docstrings.jl#L189-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.sinc_sep" href="#SeparableFunctions.sinc_sep"><code>SeparableFunctions.sinc_sep</code></a> — <span class="docstring-category">Function</span></header><section><div><p>sinc_sep([::Type{TA},] sz::NTuple{N, Int}; pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</p><p>yields the outer product of sinc functions. This corresponds to the diffraction pattern of a rectangular aperture. Note that it is not circularly symmetric.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><p>returns an iterable with the one-dimensional arrays, which can be used via <code>.*(res...)</code> wiht <code>res</code> being the result of calling this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/5bbfed019bc2376b86652d2031862d9e4b1d0c96/src/docstrings.jl#L178-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.sinc_col" href="#SeparableFunctions.sinc_col"><code>SeparableFunctions.sinc_col</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sinc_col([::Type{TA},] sz::NTuple{N, Int}; pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>yields the outer product of sinc functions. This corresponds to the diffraction pattern of a rectangular aperture. Note that it is not circularly symmetric.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><p>returns the collected N-dimensional array. #Example</p><pre><code class="language-julia-repl">julia&gt; pos = (1.1, 0.2); 
julia&gt; my_sinc = sinc_col((6,5); pos=pos)
6×5 Matrix{Float32}:
  0.0020403   -0.00374056   0.0224433   0.00561083  -0.0024937
 -0.00269847   0.00494719  -0.0296831  -0.00742078   0.00329812
  0.00398345  -0.00730299   0.0438179   0.0109545   -0.00486866
 -0.00760477   0.0139421   -0.0836524  -0.0209131    0.00929472
  0.0836524   -0.153363     0.920177    0.230044    -0.102242
  0.00929472  -0.0170403    0.102242    0.0255605   -0.0113602</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/5bbfed019bc2376b86652d2031862d9e4b1d0c96/src/docstrings.jl#L150-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.exp_ikx_sep" href="#SeparableFunctions.exp_ikx_sep"><code>SeparableFunctions.exp_ikx_sep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">exp_ikx_sep([::Type{TA},] sz::NTuple{N, Int}; pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>yield an <code>exp.(1im .* k .* Δx)</code> function. A scaling of one means that the <code>shift_by</code> argument corresponds to <code>Δx</code> in integer pixels, but the term is in Fourier space. Note that the meaning of <code>scale</code> is different compared to the version in <code>IndexFunArray.jl</code>. Here the default scaling of 1.0 corresponds to the default scaling of ScaFT in <code>IndexFunArrays.jl</code>.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><ul><li><code>shift_by</code>:  a vector defining the real-space shift that would be caused by this function being multiplied in Fourier-space.</li></ul><p>returns an iterable with the one-dimensional arrays, which can be used via <code>.*(res...)</code> wiht <code>res</code> being the result of calling this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/5bbfed019bc2376b86652d2031862d9e4b1d0c96/src/docstrings.jl#L310-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.exp_ikx_col" href="#SeparableFunctions.exp_ikx_col"><code>SeparableFunctions.exp_ikx_col</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">exp_ikx_col([::Type{TA},] sz::NTuple{N, Int}; pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>yield an <code>exp.(1im .* k .* Δx)</code> function. A scaling of one means that the <code>shift_by</code> argument corresponds to <code>Δx</code> in integer pixels, but the term is in Fourier space. Note that the meaning of <code>scale</code> is different compared to the version in <code>IndexFunArray.jl</code>. Here the default scaling of 1.0 corresponds to the default scaling of ScaFT in <code>IndexFunArrays.jl</code>.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><ul><li><code>shift_by</code>:  a vector defining the real-space shift that would be caused by this function being multiplied in Fourier-space.</li></ul><p>returns the collected N-dimensional array. #Example</p><pre><code class="language-julia-repl">julia&gt; pos = (1.1, 0.2); 
julia&gt; my_exp_ikx = exp_ikx_col((6,5); shift_by=(1.0,0.0), pos=pos)
6×5 Matrix{ComplexF32}:
 -0.406737-0.913545im  -0.406737-0.913545im  -0.406737-0.913545im  -0.406737-0.913545im  -0.406737-0.913545im
 -0.994522-0.104528im  -0.994522-0.104528im  -0.994522-0.104528im  -0.994522-0.104528im  -0.994522-0.104528im
 -0.587785+0.809017im  -0.587785+0.809017im  -0.587785+0.809017im  -0.587785+0.809017im  -0.587785+0.809017im
  0.406737+0.913545im   0.406737+0.913545im   0.406737+0.913545im   0.406737+0.913545im   0.406737+0.913545im
  0.994522+0.104528im   0.994522+0.104528im   0.994522+0.104528im   0.994522+0.104528im   0.994522+0.104528im
  0.587785-0.809017im   0.587785-0.809017im   0.587785-0.809017im   0.587785-0.809017im   0.587785-0.809017im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/5bbfed019bc2376b86652d2031862d9e4b1d0c96/src/docstrings.jl#L278-L291">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« SeparableFunctions.jl</a><a class="docs-footer-nextpage" href="../radial/">Radial Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 10 February 2023 20:31">Friday 10 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
