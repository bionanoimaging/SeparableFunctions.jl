<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SeparableFunctions.jl · SeparableFunctions.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SeparableFunctions.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>SeparableFunctions.jl</a><ul class="internal"><li><a class="tocitem" href="#SeparableFunctions-Interface"><span>SeparableFunctions Interface</span></a></li><li><a class="tocitem" href="#SeparableFunctions-Interface-2"><span>SeparableFunctions Interface</span></a></li><li class="toplevel"><a class="tocitem" href="#Radial-functions"><span>Radial functions</span></a></li></ul></li><li><a class="tocitem" href="separables/">Concrete Separable Functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>SeparableFunctions.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>SeparableFunctions.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SeparableFunctions.jl"><a class="docs-heading-anchor" href="#SeparableFunctions.jl">SeparableFunctions.jl</a><a id="SeparableFunctions.jl-1"></a><a class="docs-heading-anchor-permalink" href="#SeparableFunctions.jl" title="Permalink"></a></h1><h2 id="SeparableFunctions-Interface"><a class="docs-heading-anchor" href="#SeparableFunctions-Interface">SeparableFunctions Interface</a><a id="SeparableFunctions-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#SeparableFunctions-Interface" title="Permalink"></a></h2><p>The abstract <code>SeparableFunctions</code> definition</p><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions" href="#SeparableFunctions"><code>SeparableFunctions</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Calculates multidimensional functions faster by exploiting their separability. Often a function involves an operation such as a (complex) exponential which by itself is computationally relatively heavy. Yet a number of multidimenstional functions are separable, which means that they can be written as a product (or sum) of single-dimensional functions. A good example of a separable function is a Gaussian function, which can be written as a product of a purely X-dependend Gaussian with a purely Y-dependend Gaussian.</p><p>In this package, multidimensional functions are computed by first calculating their single-dimensional values and then creating the final multidimensional result by an outer product. Since multiplications and the broadcasting mechanism of Julia are fast compared to the evaluation of the function at each multidimensional position, the final result is calculated faster. The typical speedup can be an order of magnitude.</p><p>The package offers a general way of calculating separable functions as well as a <code>LazyArrays</code> version of that function which can then be used inside other expressions. The non-lazy version should currently also work with <code>CUDA.jl</code>, however the <code>LazyArrays</code> version does not. To nevertheless use separable expressions in <code>CUDA.jl</code>, you can reside to externally applying the broadcast operator to the separable expression (see the <code>gaussian_sep</code> example below).</p><p>The package further offers a number of predifined separable function implementations such as <code>gaussian_col()</code> collects a multidimensional array of a multidimensional Gaussian via a fast seperable implementation, <code>gaussian_lz()</code> yields a lazy representation via <code>LazyArrays</code> and <code>sep = gaussian_sep()</code> yields an iterable of separable pre-oriented vectors which can easily be mutually combined via <code>.*(sep...)</code>.</p><p>Another noteworthy example is the complex plain wave as represented by the respective function <code>exp_ikx_col()</code>, <code>exp_ikx_lz()</code>, <code>exp_ikx_sep()</code>.</p><p>All separable functions share a common interface with Standard non-named arguments</p><ul><li>the first optional argument being the type of the result array. Examples are <code>Array{Float64}</code>, <code>CuArray{Float32}</code> and the default depends on the function but uses a 32-bit result type where applicable.</li><li>the next argument is the <code>size</code> of the result data supplied as a tuple.</li><li>optionally a further argument can specify the <code>position</code> of zero of the array with respect to <code>offset</code> as given below. This allows for convenient N-dimensional shifting of the functions. </li></ul><p>Named arguments:</p><ul><li><code>offset</code>: is a optional named argument specifying center of the array. By default the Fourier center, <code>size().÷2 .+ 1</code> is chosen.</li><li><code>scale</code>: multiplies the axes with these factors. This can be interpreted as a <code>pixelsize</code>.</li></ul><p>Some functions have additional named arguments. E.g. <code>gaussian</code> has the additional named argument <code>sigma</code> specifying the width of the gaussian, even though this can also be controlled via <code>scale</code>.  Note that this nomenclature is in large parts identical to the package <code>IndexFunArrays.jl</code>.</p><p>In general arguments can be supplied as single scalar values or vectors. If a scalar value is supplied, it will automatically be replicated as a vector. E.g. <code>sigma=10.0</code> for a  2-dimensional array will be interpreted as <code>sigma=(10.0, 10.0)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/SeparableFunctions.jl#L1-L26">source</a></section></article><p>Here you can find the docstrings of currently implemented functions.</p><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.calc_radial_symm!" href="#SeparableFunctions.calc_radial_symm!"><code>SeparableFunctions.calc_radial_symm!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">calc_radial_symm!(arr::TA, fct; scale = one(real(T)), myrr2sep = rr2_sep(size(arr); scale=scale, offset=size(arr).÷2 .+1)) where {N,T}</code></pre><p>evaluates the radial function <code>fct</code> over the entire array. The function needs to accept the square of the radius as argument! The calculation is done fast by only evaluating on the first quadrant and replicating the results by copy operations using <code>copy_corners!()</code>.</p><p>#Arguments</p><ul><li><p><code>arr</code>:    The array into which to evaluate the radial function </p></li><li><p><code>fct</code>:        The radial function of the squared radius, to be evaluate on the array coordinates. </p></li><li><p><code>scale</code>:      the vetorized scaling of the pixels (only used, if myrr2sep is not supplied by the user)</p></li><li><p><code>myrr2sep</code>:   The separable xx^2 and yy^2 etc. information as obtained by <code>rr2_sep()</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/radial.jl#L96-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.copy_corners!" href="#SeparableFunctions.copy_corners!"><code>SeparableFunctions.copy_corners!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">copy_corners!(arr::AbstractArray{T,N}) where {T,N}</code></pre><p>replicates the first N-dimensional quadrant my several mirror operations over the entire array. The overwrites the entire array with the (mirrored) content of the first quadrant!</p><p>#Arguments</p><ul><li><code>arr</code>:    The array in which the copy operations are performed</li><li><code>speedup_last_dim=true</code>:  if <code>true</code> a one-dimensional assignment trick is used for the last non-singleton dimension.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/radial.jl#L19-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.separable_view" href="#SeparableFunctions.separable_view"><code>SeparableFunctions.separable_view</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">separable_view{N}(fct, sz, args...; pos=zero(real(eltype(AT))), offset =  sz.÷2 .+1, scale = one(real(eltype(AT))), operation = .*)</code></pre><p>creates an array view of an N-dimensional separable function. Note that this view consumes much less memory than a full allocation of the collected result. Note also that an N-dimensional calculation expression may be much slower than this view reprentation of a product of N one-dimensional arrays. See the example below.</p><p><strong>Arguments:</strong></p><ul><li><code>fct</code>:          The separable function, with a number of arguments corresponding to <code>length(args)</code>, each corresponding to a vector of separable inputs of length N.                 The first argument of this function is a Tuple corresponding the centered indices.</li><li><code>sz</code>:           The size of the N-dimensional array to create</li><li><code>args</code>...:      a list of arguments, each being an N-dimensional vector</li><li><code>offset</code>:       position of the center from which the position is measured</li><li><code>scale</code>:        defines the pixel size as vector or scalar. Default: 1.0.</li><li><code>operation</code>:    the separable operation connecting the separable dimensions</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia">julia&gt; fct = (r, sz, pos, sigma)-&gt; exp(-(r-pos)^2/(2*sigma^2))
julia&gt; my_gaussian = separable_view(fct, (6,5), (0.1,0.2), (0.5,1.0))
(6-element Vector{Float64}) .* (1×5 Matrix{Float64}):
 3.99823e-10  2.18861e-9   4.40732e-9   3.26502e-9   8.89822e-10
 1.3138e-5    7.19168e-5   0.000144823  0.000107287  2.92392e-5
 0.00790705   0.0432828    0.0871609    0.0645703    0.0175975
 0.0871609    0.477114     0.960789     0.71177      0.19398
 0.0175975    0.0963276    0.19398      0.143704     0.0391639
 6.50731e-5   0.000356206  0.000717312  0.000531398  0.000144823</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/general.jl#L64-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.separable_create" href="#SeparableFunctions.separable_create"><code>SeparableFunctions.separable_create</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">separable_create([::Type{TA},] fct, sz::NTuple{N, Int}, args...; pos=zero(real(eltype(AT))), offset =  sz.÷2 .+1, scale = one(real(eltype(AT))), operation = *, kwargs...) where {TA, N}</code></pre><p>creates an array view of an N-dimensional separable function including memory allocation and collection. See the example below.</p><p><strong>Arguments:</strong></p><ul><li><code>fct</code>:          The separable function, with a number of arguments corresponding to <code>length(args)</code>, each corresponding to a vector of separable inputs of length N.                 The first argument of this function is a Tuple corresponding the centered indices.</li><li><code>sz</code>:           The size of the N-dimensional array to create</li><li><code>args</code>...:      a list of arguments, each being an N-dimensional vector</li><li><code>offset</code>:       position of the center from which the position is measured</li><li><code>scale</code>:        defines the pixel size as vector or scalar. Default: 1.0.</li><li><code>operation</code>:    the separable operation connecting the separable dimensions</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia">julia&gt; fct = (r, sz, sigma)-&gt; exp(-r^2/(2*sigma^2))
julia&gt; my_gaussian = separable_create(fct, (6,5), (0.5,1.0); pos=(0.1,0.2))
6×5 Matrix{Float32}:
 3.99823f-10  2.18861f-9   4.40732f-9   3.26502f-9   8.89822f-10
 1.3138f-5    7.19168f-5   0.000144823  0.000107287  2.92392f-5
 0.00790705   0.0432828    0.0871608    0.0645703    0.0175975
 0.0871608    0.477114     0.960789     0.71177      0.19398
 0.0175975    0.0963276    0.19398      0.143704     0.0391639
 6.50731f-5   0.000356206  0.000717312  0.000531398  0.000144823</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/general.jl#L103-L130">source</a></section></article><p>&lt;!– </p><h2 id="SeparableFunctions-Interface-2"><a class="docs-heading-anchor" href="#SeparableFunctions-Interface-2">SeparableFunctions Interface</a><a class="docs-heading-anchor-permalink" href="#SeparableFunctions-Interface-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.gaussian_col" href="#SeparableFunctions.gaussian_col"><code>SeparableFunctions.gaussian_col</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gaussian_col([::Type{TA},] sz::NTuple{N, Int}; sigma=ones(eltype(TA),N), pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>creates a multidimensional Gaussian by exployting separability speeding up the calculation.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><ul><li><code>sigma</code>:  tuple of standard-deviation along each dimensional</li></ul><p>returns the collected N-dimensional array.</p><p>#Example</p><pre><code class="language-julia-repl">julia&gt; pos = (1.1, 0.2); sigma = (0.5, 1.0);
julia&gt; my_gaussian = gaussian_col((6,5); sigma=sigma, pos=pos)
6×5 Matrix{Float32}:
    2.22857f-16  1.21991f-15  2.4566f-15   1.81989f-15  4.95978f-16
    3.99823f-10  2.18861f-9   4.40732f-9   3.26502f-9   8.89822f-10
    1.3138f-5    7.19168f-5   0.000144823  0.000107287  2.92392f-5
    0.00790705   0.0432828    0.0871608    0.0645703    0.0175975
    0.0871608    0.477114     0.960789     0.71177      0.19398
    0.0175975    0.0963276    0.19398      0.143704     0.0391639</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/docstrings.jl#L21-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.gaussian_lz" href="#SeparableFunctions.gaussian_lz"><code>SeparableFunctions.gaussian_lz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gaussian_lz([::Type{TA},] sz::NTuple{N, Int}; sigma=ones(eltype(TA),N), pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>creates a multidimensional Gaussian by exployting separability speeding up the calculation.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><ul><li><code>sigma</code>:  tuple of standard-deviation along each dimensional</li></ul><p>returns the a lazy version of an N-dimensional array only using memory for the separated 1-dimensional arrays. See the <code>_col</code> version for an example.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/docstrings.jl#L44-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.gaussian_sep" href="#SeparableFunctions.gaussian_sep"><code>SeparableFunctions.gaussian_sep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gaussian_sep([::Type{TA},] sz::NTuple{N, Int}; sigma=ones(eltype(TA),N), pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>creates a multidimensional Gaussian by exployting separability speeding up the calculation.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><ul><li><code>sigma</code>:  tuple of standard-deviation along each dimensional</li></ul><p>returns an iterable with the one-dimensional arrays, which can be used via <code>.*(res...)</code> wiht <code>res</code> being the result of calling this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/docstrings.jl#L54-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.normal_col" href="#SeparableFunctions.normal_col"><code>SeparableFunctions.normal_col</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normal_col([::Type{TA},] sz::NTuple{N, Int}; sigma=ones(eltype(TA),N), pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>creates a multidimensional normalized Gaussian by exployting separability speeding up the calculation. The integral of the multidimensional array, if it where infinite, is normalized to one.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><ul><li><code>sigma</code>:  tuple of standard-deviation along each dimensional</li></ul><p>returns the collected N-dimensional array. #Example</p><pre><code class="language-julia-repl">julia&gt; pos = (1.1, 0.2); sigma = (0.5, 1.0);
julia&gt; my_normal = normal_col((6,5); sigma=sigma, pos=pos)
6×5 Matrix{Float32}:
    7.09377f-17  3.88309f-16  7.81959f-16  5.79289f-16  1.57875f-16
    1.27268f-10  6.96656f-10  1.40289f-9   1.03929f-9   2.83239f-10
    4.18196f-6   2.28918f-5   4.60985f-5   3.41506f-5   9.30713f-6
    0.00251689   0.0137773    0.0277442    0.0205534    0.00560145
    0.0277442    0.15187      0.305829     0.226564     0.0617458
    0.00560145   0.030662     0.0617458    0.0457424    0.0124663</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/docstrings.jl#L66-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.normal_lz" href="#SeparableFunctions.normal_lz"><code>SeparableFunctions.normal_lz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normal_lz([::Type{TA},] sz::NTuple{N, Int}; sigma=ones(eltype(TA),N), pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>creates a multidimensional normalized Gaussian by exployting separability speeding up the calculation. The integral of the multidimensional array, if it where infinite, is normalized to one.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><ul><li><code>sigma</code>:  tuple of standard-deviation along each dimensional</li></ul><p>returns the a lazy version of an N-dimensional array only using memory for the separated 1-dimensional arrays. See the <code>_col</code> version for an example.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/docstrings.jl#L88-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.normal_sep" href="#SeparableFunctions.normal_sep"><code>SeparableFunctions.normal_sep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normal_sep([::Type{TA},] sz::NTuple{N, Int}; sigma=ones(eltype(TA),N), pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>creates a multidimensional normalized Gaussian by exployting separability speeding up the calculation. The integral of the multidimensional array, if it where infinite, is normalized to one.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><ul><li><code>sigma</code>:  tuple of standard-deviation along each dimensional</li></ul><p>returns an iterable with the one-dimensional arrays, which can be used via <code>.*(res...)</code> wiht <code>res</code> being the result of calling this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/docstrings.jl#L98-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.ramp_col" href="#SeparableFunctions.ramp_col"><code>SeparableFunctions.ramp_col</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ramp_col([::Type{TA},] sz::NTuple{N, Int}; slope, pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>creates an N-dimensional ramp along the gradient-direction defined by <code>slope</code>. Note that this disagrees with the nomenclature of the ramp-function defined in <code>IndexFunArrays.jl</code>.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><ul><li><code>slope</code>:  a vector defining the N-dimensional gradient of the ramp.</li></ul><p>returns the collected N-dimensional array. #Example julia&gt; my<em>ramp = ramp</em>col((6,5); slope=(0.0,0.5), pos=pos) 6×5 Matrix{Float32}:  -1.1  -0.6  -0.1  0.4  0.9  -1.1  -0.6  -0.1  0.4  0.9  -1.1  -0.6  -0.1  0.4  0.9  -1.1  -0.6  -0.1  0.4  0.9  -1.1  -0.6  -0.1  0.4  0.9  -1.1  -0.6  -0.1  0.4  0.9 ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/docstrings.jl#L234-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.ramp_lz" href="#SeparableFunctions.ramp_lz"><code>SeparableFunctions.ramp_lz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ramp_lz([::Type{TA},] sz::NTuple{N, Int}; slope, pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>creates an N-dimensional ramp along the gradient-direction defined by <code>slope</code>. Note that this disagrees with the nomenclature of the ramp-function defined in <code>IndexFunArrays.jl</code>.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><ul><li><code>slope</code>:  a vector defining the N-dimensional gradient of the ramp.</li></ul><p>returns the a lazy version of an N-dimensional array only using memory for the separated 1-dimensional arrays. See the <code>_col</code> version for an example.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/docstrings.jl#L254-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.ramp_sep" href="#SeparableFunctions.ramp_sep"><code>SeparableFunctions.ramp_sep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ramp_sep([::Type{TA},] sz::NTuple{N, Int}; slope, pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>creates an N-dimensional ramp along the gradient-direction defined by <code>slope</code>. Note that this disagrees with the nomenclature of the ramp-function defined in <code>IndexFunArrays.jl</code>.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><ul><li><code>slope</code>:  a vector defining the N-dimensional gradient of the ramp.</li></ul><p>returns an iterable with the one-dimensional arrays, which can be used via <code>.*(res...)</code> wiht <code>res</code> being the result of calling this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/docstrings.jl#L264-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.rr2_col" href="#SeparableFunctions.rr2_col"><code>SeparableFunctions.rr2_col</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rr2_col([::Type{TA},] sz::NTuple{N, Int}; pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>yields the absolute square of the distance to the zero-position.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><p>returns the collected N-dimensional array. #Example</p><pre><code class="language-julia-repl">julia&gt; pos = (1.1, 0.2); 
julia&gt; my_rr2 = rr2_col((6,5); pos=pos)
6×5 Matrix{Float32}:
    21.65  18.25  16.85  17.45  20.05
    14.45  11.05   9.65  10.25  12.85
    9.25   5.85   4.45   5.05   7.65
    6.05   2.65   1.25   1.85   4.45
    4.85   1.45   0.05   0.65   3.25
    5.65   2.25   0.85   1.45   4.05</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/docstrings.jl#L111-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.rr2_lz" href="#SeparableFunctions.rr2_lz"><code>SeparableFunctions.rr2_lz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rr2_lz([::Type{TA},] sz::NTuple{N, Int}; pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>yields the absolute square of the distance to the zero-position.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><p>returns the a lazy version of an N-dimensional array only using memory for the separated 1-dimensional arrays. See the <code>_col</code> version for an example.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/docstrings.jl#L131-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.rr2_sep" href="#SeparableFunctions.rr2_sep"><code>SeparableFunctions.rr2_sep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rr2_sep([::Type{TA},] sz::NTuple{N, Int}; pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>yields the absolute square of the distance to the zero-position.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><p>returns an iterable with the one-dimensional arrays, which can be used via <code>.+(res...)</code> wiht <code>res</code> being the result of calling this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/docstrings.jl#L139-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.box_col" href="#SeparableFunctions.box_col"><code>SeparableFunctions.box_col</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">box_col([::Type{TA},] sz::NTuple{N, Int}; boxsize=sz./2, pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>creates a Boolean box, being True inside and False outside. The side-length of the box can be defined via the argument <code>boxsize</code>.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><ul><li><code>boxsize</code>:  a vector defining each sidelength of the box.</li></ul><p>returns the collected N-dimensional array. #Example</p><pre><code class="language-julia-repl">julia&gt; pos = (1.1, 0.2); 
julia&gt; my_box = box_col((6,5); pos=pos)
6×5 BitMatrix:
 0  0  0  0  0
 0  0  0  0  0
 0  0  0  0  0
 0  1  1  1  0
 0  1  1  1  0
 0  1  1  1  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/docstrings.jl#L189-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.box_lz" href="#SeparableFunctions.box_lz"><code>SeparableFunctions.box_lz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">box_lz([::Type{TA},] sz::NTuple{N, Int}; boxsize=sz./2, pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>creates a Boolean box, being True inside and False outside. The side-length of the box can be defined via the argument <code>boxsize</code>.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><ul><li><code>boxsize</code>:  a vector defining each sidelength of the box.</li></ul><p>returns the a lazy version of an N-dimensional array only using memory for the separated 1-dimensional arrays. See the <code>_col</code> version for an example.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/docstrings.jl#L211-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.box_sep" href="#SeparableFunctions.box_sep"><code>SeparableFunctions.box_sep</code></a> — <span class="docstring-category">Function</span></header><section><div><p>box_sep([::Type{TA},] sz::NTuple{N, Int}; boxsize=sz./2, pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</p><p>creates a Boolean box, being True inside and False outside. The side-length of the box can be defined via the argument <code>boxsize</code>.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><ul><li><code>boxsize</code>:  a vector defining each sidelength of the box.</li></ul><p>returns an iterable with the one-dimensional arrays, which can be used via <code>.*(res...)</code> wiht <code>res</code> being the result of calling this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/docstrings.jl#L221-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.sinc_col" href="#SeparableFunctions.sinc_col"><code>SeparableFunctions.sinc_col</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sinc_col([::Type{TA},] sz::NTuple{N, Int}; pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>yields the outer product of sinc functions. This corresponds to the diffraction pattern of a rectangular aperture. Note that it is not circularly symmetric.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><p>returns the collected N-dimensional array. #Example</p><pre><code class="language-julia-repl">julia&gt; pos = (1.1, 0.2); 
julia&gt; my_sinc = sinc_col((6,5); pos=pos)
6×5 Matrix{Float32}:
  0.0020403   -0.00374056   0.0224433   0.00561083  -0.0024937
 -0.00269847   0.00494719  -0.0296831  -0.00742078   0.00329812
  0.00398345  -0.00730299   0.0438179   0.0109545   -0.00486866
 -0.00760477   0.0139421   -0.0836524  -0.0209131    0.00929472
  0.0836524   -0.153363     0.920177    0.230044    -0.102242
  0.00929472  -0.0170403    0.102242    0.0255605   -0.0113602</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/docstrings.jl#L150-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.sinc_lz" href="#SeparableFunctions.sinc_lz"><code>SeparableFunctions.sinc_lz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sinc_lz([::Type{TA},] sz::NTuple{N, Int}; pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>yields the outer product of sinc functions. This corresponds to the diffraction pattern of a rectangular aperture. Note that it is not circularly symmetric.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><p>returns the a lazy version of an N-dimensional array only using memory for the separated 1-dimensional arrays. See the <code>_col</code> version for an example.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/docstrings.jl#L170-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.sinc_sep" href="#SeparableFunctions.sinc_sep"><code>SeparableFunctions.sinc_sep</code></a> — <span class="docstring-category">Function</span></header><section><div><p>sinc_sep([::Type{TA},] sz::NTuple{N, Int}; pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</p><p>yields the outer product of sinc functions. This corresponds to the diffraction pattern of a rectangular aperture. Note that it is not circularly symmetric.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><p>returns an iterable with the one-dimensional arrays, which can be used via <code>.*(res...)</code> wiht <code>res</code> being the result of calling this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/docstrings.jl#L178-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.exp_ikx_col" href="#SeparableFunctions.exp_ikx_col"><code>SeparableFunctions.exp_ikx_col</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">exp_ikx_col([::Type{TA},] sz::NTuple{N, Int}; pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>yield an <code>exp.(1im .* k .* Δx)</code> function. A scaling of one means that the <code>shift_by</code> argument corresponds to <code>Δx</code> in integer pixels, but the term is in Fourier space. Note that the meaning of <code>scale</code> is different compared to the version in <code>IndexFunArray.jl</code>. Here the default scaling of 1.0 corresponds to the default scaling of ScaFT in <code>IndexFunArrays.jl</code>.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><ul><li><code>shift_by</code>:  a vector defining the real-space shift that would be caused by this function being multiplied in Fourier-space.</li></ul><p>returns the collected N-dimensional array. #Example</p><pre><code class="language-julia-repl">julia&gt; pos = (1.1, 0.2); 
julia&gt; my_exp_ikx = exp_ikx_col((6,5); shift_by=(1.0,0.0), pos=pos)
6×5 Matrix{ComplexF32}:
 -0.406737-0.913545im  -0.406737-0.913545im  -0.406737-0.913545im  -0.406737-0.913545im  -0.406737-0.913545im
 -0.994522-0.104528im  -0.994522-0.104528im  -0.994522-0.104528im  -0.994522-0.104528im  -0.994522-0.104528im
 -0.587785+0.809017im  -0.587785+0.809017im  -0.587785+0.809017im  -0.587785+0.809017im  -0.587785+0.809017im
  0.406737+0.913545im   0.406737+0.913545im   0.406737+0.913545im   0.406737+0.913545im   0.406737+0.913545im
  0.994522+0.104528im   0.994522+0.104528im   0.994522+0.104528im   0.994522+0.104528im   0.994522+0.104528im
  0.587785-0.809017im   0.587785-0.809017im   0.587785-0.809017im   0.587785-0.809017im   0.587785-0.809017im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/docstrings.jl#L278-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.exp_ikx_lz" href="#SeparableFunctions.exp_ikx_lz"><code>SeparableFunctions.exp_ikx_lz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">exp_ikx_lz([::Type{TA},] sz::NTuple{N, Int}; pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>creates a Boolean box, being True inside and False outside. The side-length of the box can be defined via the argument <code>boxsize</code>.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><ul><li><code>shift_by</code>:  a vector defining the real-space shift that would be caused by this function being multiplied in Fourier-space.</li></ul><p>returns the a lazy version of an N-dimensional array only using memory for the separated 1-dimensional arrays. See the <code>_col</code> version for an example.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/docstrings.jl#L300-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.exp_ikx_sep" href="#SeparableFunctions.exp_ikx_sep"><code>SeparableFunctions.exp_ikx_sep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">exp_ikx_sep([::Type{TA},] sz::NTuple{N, Int}; pos=zeros(eltype(TA),N), offset=sz.÷2 .+1, scale=1.0) where {TA, N}</code></pre><p>yield an <code>exp.(1im .* k .* Δx)</code> function. A scaling of one means that the <code>shift_by</code> argument corresponds to <code>Δx</code> in integer pixels, but the term is in Fourier space. Note that the meaning of <code>scale</code> is different compared to the version in <code>IndexFunArray.jl</code>. Here the default scaling of 1.0 corresponds to the default scaling of ScaFT in <code>IndexFunArrays.jl</code>.To create the array on the GPU supply for example CuArray{Float32} as the array type. Note that the <code>_col</code> version yields a collected array, the <code>_lz</code> version a <code>LazyArray</code> and the <code>_sep</code> version an iterable of one-dimensional but oriented arrays, which can be used via the <code>.*(res...)</code> syntax with <code>res</code> being the result of the <code>_sep</code> call.</p><p><strong>Arguments</strong></p><ul><li><p><code>TA</code>:     optionally an array type can be supplied. The default is Array{Float32}</p></li><li><p><code>sz</code>:     size of the result array</p></li><li><p><code>pos</code>:    position of the gaussian in relationship to the center defined by <code>offset</code></p></li><li><p><code>offset</code>: center position of the array</p></li></ul><ul><li><code>shift_by</code>:  a vector defining the real-space shift that would be caused by this function being multiplied in Fourier-space.</li></ul><p>returns an iterable with the one-dimensional arrays, which can be used via <code>.*(res...)</code> wiht <code>res</code> being the result of calling this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/docstrings.jl#L310-L323">source</a></section></article><p>–&gt;</p><h1 id="Radial-functions"><a class="docs-heading-anchor" href="#Radial-functions">Radial functions</a><a id="Radial-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Radial-functions" title="Permalink"></a></h1><p>These functions are purely radial, in which case only a quadrant is computed and then copied. They are based on a separable view version of <code>rr2</code> but then continue to calculate on a corner of a grid, which is (as a last step) replicated and mirrored.</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>calc_radial_symm!</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.calc_radial_symm" href="#SeparableFunctions.calc_radial_symm"><code>SeparableFunctions.calc_radial_symm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">calc_radial_symm([::Type{TA},] sz::NTuple,  fct; scale = one(real(T)), myrr2sep = rr2_sep(size(arr); scale=scale, offset=size(arr).÷2 .+1)) where {N,T}</code></pre><p>evaluates the radial function <code>fct</code> in a newly created array. The function needs to accept the square of the radius as argument! The calculation is done fast by only evaluating on the first quadrant and replicating the results by copy operations using <code>copy_corners!()</code>.</p><p>#Arguments</p><ul><li><p><code>TA</code>:         The array type for the newly created array. </p></li><li><p><code>sz</code>:         The size of the newly created array. </p></li><li><p><code>fct</code>:        The radial function of the squared radius, to be evaluate on the array coordinates. </p></li><li><p><code>scale</code>:      the vetorized scaling of the pixels (only used, if myrr2sep is not supplied by the user)</p></li><li><p><code>myrr2sep</code>:   The separable xx^2 and yy^2 etc. information as obtained by <code>rr2_sep()</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/radial.jl#L121-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.propagator_col" href="#SeparableFunctions.propagator_col"><code>SeparableFunctions.propagator_col</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">propagator_col([]::Type{TA},] sz::NTuple{N, Int}; Δz=one(eltype(TA)), k_max=0.5f0, scale=0.5f0 ./ (max.(sz ./ 2, 1))) where{TA, N}</code></pre><p>generates a propagator for propagating optical fields via exp(i kz Δz) with kz=sqrt(k0^2-kx^2-ky^2). The k-space radius is stated by k_max relative to the Nyquist frequency, as long as the scale remains to be 1 ./ (2 max.(sz ./ 2, 1))).</p><p>#Arguments</p><ul><li><code>TA</code>:     type of the array to generate. E.g. Array{Float64} or CuArray{Float32}.</li><li><code>sz</code>:     size of the array to generate.  If a 3rd dimension is present, a stack a propagators is returned, one for each multiple of Δz.</li><li><code>Δz</code>:     distance in Z to propagate per slice.</li><li><code>k_max</code>:  maximum propagation radius in k-space. I.e. limit of the k-sphere. This is not the aperture limit!</li><li><code>scale</code>:  specifies how to interpret k-space positions. Should remain to be 1 ./ (2 max.(sz ./ 2, 1))).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/specific.jl#L91-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.propagator_col!" href="#SeparableFunctions.propagator_col!"><code>SeparableFunctions.propagator_col!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">propagator_col(arr::AbstractArray{T,N}; Δz=one(eltype(TA)), k_max=0.5f0, scale=0.5f0 ./ (max.(sz ./ 2, 1))) where{TA, N}</code></pre><p>generates a propagator for propagating optical fields via exp(i kz Δz) with kz=sqrt(k0^2-kx^2-ky^2). The k-space radius is stated by k_max relative to the Nyquist frequency, as long as the scale remains to be 1 ./ (2 max.(sz ./ 2, 1))).</p><p>#Arguments</p><ul><li><code>arr</code>:    the array to fill with propagators. If a 3rd dimension is present, a stack a propagators is returned, one for each multiple of Δz.</li><li><code>Δz</code>:     distance in Z to propagate per slice.</li><li><code>k_max</code>:  maximum propagation radius in k-space. I.e. limit of the k-sphere. This is not the aperture limit!</li><li><code>scale</code>:  specifies how to interpret k-space positions. Should remain to be 1 ./ (2 max.(sz ./ 2, 1))).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/specific.jl#L117-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SeparableFunctions.phase_kz_col" href="#SeparableFunctions.phase_kz_col"><code>SeparableFunctions.phase_kz_col</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">phase_kz_col!(arr::AbstractArray{T,N}; Δz=one(eltype(TA)), k_max=0.5f0, scale=0.5f0 ./ (max.(sz ./ 2, 1))) where{TA, N}</code></pre><p>Calculates a propagation phase (without the 2pi factor!) for a given z-position, which can be defined via a 3rd entry in the <code>offset</code> supplied to the function. By default, Nyquist sampling it is assumed such that the lateral k<em>xy corresponds to the XY border in frequency space at the edge  of the Ewald circle. However, via the xy <code>scale</code> entries the k</em>max can be set appropriately. The propagation equation uses offset[3] .* sqrt.(1-kxy<em>rel^2) as the propagation phase. Therefore the Z-propagation distance (offset[3]) has to be specified in  units of the wavelength in the medium (<code>λ = n*λ₀</code>). Note that since the phase is normalized to 1 instead of 2pi, you need to use this phase in the following sense: `cispi.(2.*phase</em>kz(...))`.</p><p>#Arguments</p><ul><li><code>arr</code>:    the array to fill with propagators. If a 3rd dimension is present, a stack a propagators is returned, one for each multiple of Δz.</li><li><code>Δz</code>:     distance in Z to propagate per slice.</li><li><code>k_max</code>:  maximum propagation radius in k-space. I.e. limit of the k-sphere. This is not the aperture limit!</li><li><code>scale</code>:  specifies how to interpret k-space positions. Should remain to be 1 ./ (2 max.(sz ./ 2, 1))).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bionanoimaging/SeparableFunctions.jl/blob/3f48367fd30797a7bf8131a766d9468502107929/src/specific.jl#L150-L166">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>phase_kz_col!</code>. Check Documenter&#39;s build log for details.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="separables/">Concrete Separable Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 27 August 2022 13:06">Saturday 27 August 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
